<!DOCTYPE html>
<html lang="en-GB">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BHEJTM2PGH"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-BHEJTM2PGH');
</script>
<meta charset="UTF-8" />
<title>No Context Cinema Club ‚Äì Episode</title>
<meta name="description" content="Listen to No Context Cinema Club episodes directly on-site." />
<meta name="robots" content="index,follow" />
<link rel="canonical" href="https://nocontextcinemaclub.com/pages/episode.html" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="website-version" content="1.16.3" />
<link rel="stylesheet" href="/assets/css/site.css" />
<style>
:root {
  --bg: #0f0f0f;
  --card: #1b1b1b;
  --text: #ffffff;
  --muted: #aaaaaa;
  --line: rgba(255, 255, 255, 0.1);
  --accent-rob: #d46a2a;
  --brand-orange: var(--accent-rob);
}

* { box-sizing: border-box; }

html {
  font-family: Arial, Helvetica, sans-serif;
}

body {
  background: var(--bg);
  color: var(--text);
  margin: 0;
  overflow-x: clip;
}

.content {
  max-width: 900px;
  margin: 0 auto 24px;
  padding: 12px 16px 0;
}

.film-card {
  display: block;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), transparent 55%), var(--card);
  border-radius: 18px;
  border: 1px solid var(--line);
  padding: 18px;
  position: relative;
  box-shadow: 0 18px 60px rgba(0, 0, 0, 0.45);
}

.detail-title {
  margin: 0;
  font-size: 28px;
  letter-spacing: -0.02em;
  line-height: 1.15;
}

.meta-line {
  margin: 8px 0 0;
  font-size: 14px;
  color: var(--muted);
}

.episode-title-meta-row {
  display: flex;
  align-items: baseline;
  gap: 8px;
}

.episode-title-meta-row .meta-line {
  margin: 0;
}

.episode-title-meta-row .meta-line::before {
  content: "¬∑";
  margin-right: 8px;
}


@media (max-width: 767px) {
  .episode-title-meta-row {
    display: block;
  }

  .episode-title-meta-row .meta-line {
    margin-top: 8px;
  }

  .episode-title-meta-row .meta-line::before {
    content: "";
    margin-right: 0;
  }
}

.episode-header-row {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  align-items: flex-start;
  flex-wrap: wrap;
  margin-bottom: 20px;
}

.episode-title-block {
  min-width: 0;
}

.rosette-stack {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  justify-content: flex-end;
}

.rosette {
  font-size: 11px;
  font-weight: 700;
  padding: 6px 12px;
  border-radius: 999px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.18), 0 2px 8px rgba(0, 0, 0, 0.45);
  color: #fff;
}

.badge-icon { font-size: 0.9em; line-height: 1; }
.rosette.rob { background: #3e5f3e; color: #d8f0d8; }
.rosette.real { background: #444; }
.rosette--kev-pick { background: var(--rosette-kev-pick); }
.rosette--listener-pick { background: var(--rosette-listener-pick); }
.rosette--new { background: var(--rosette-new); }
.rosette.other { background: #565656; }
.rosette--most-underrated { background: var(--rosette-most-underrated); }
.rosette--most-overrated { background: var(--rosette-most-overrated); }
.rosette--most-divisive { background: var(--rosette-most-divisive); }
.rosette--lost-plot { background: var(--rosette-lost-plot-bg); }
.rosette--fixed-it { background: var(--rosette-fixed-it-bg); }
.rosette--consensus { background: var(--rosette-consensus-bg); }

.episode-player {
  width: 100%;
  border-radius: 12px;
  overflow: hidden;
  background: #121212;
  border: 1px solid #353535;
  min-height: 110px;
  padding: 0;
}

.episode-player > div,
.episode-player iframe,
.episode-player .buzzsprout-player {
  width: 100% !important;
  max-width: 100% !important;
}

.episode-status {
  margin: 0;
  color: #d8d8d8;
  padding: 8px;
}

.score-row {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  align-items: stretch;
  gap: 12px;
}

.score-card {
  border-radius: 18px;
  padding: 14px;
}

.score-card--stat {
  border: 1px solid rgba(124, 74, 45, 0.88);
  background: rgba(92, 54, 31, 0.8);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06);
}

.score-stat {
  height: 100%;
  display: flex;
  flex-direction: column;
  gap: 6px;
  align-items: center;
  text-align: center;
}

.score-label {
  font-size: 12px;
  font-weight: 800;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: rgba(255, 255, 255, 0.86);
}

.score-value {
  font-size: 30px;
  font-weight: 900;
  line-height: 1;
}

.episode-grid {
  display: grid;
  grid-template-columns: minmax(220px, 260px) minmax(0, 1fr);
  grid-template-areas:
    "poster player"
    "poster scores"
    "poster synopsis";
  gap: 14px;
  align-items: start;
}

.episode-poster {
  grid-area: poster;
}

.poster {
  width: 100%;
  height: auto;
  border-radius: 10px;
  box-shadow: 0 12px 28px rgba(0, 0, 0, 0.4);
}

.episode-player { grid-area: player; min-width: 0; margin: 0; }
.episode-scores { grid-area: scores; margin: 0; }

.episode-desc {
  grid-area: synopsis;
  line-height: 1.63;
  font-size: 16px;
  color: rgba(255, 255, 255, 0.92);
  margin: 0;
}


.episode-footer-row {
  display: flex;
  justify-content: flex-end;
  margin-top: 10px;
}

.back-link {
  color: #d1632e;
  text-decoration: none;
  font-weight: 600;
}

.back-link:hover,
.back-link:focus-visible {
  text-decoration: underline;
}

@media (max-width: 768px) {
  .episode-grid {
    grid-template-columns: 1fr;
    grid-template-areas:
      "player"
      "poster"
      "scores"
      "synopsis";
    gap: 12px;
  }

  .episode-player {
    width: 100%;
    max-width: 100%;
  }

  .score-row { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<div id="site-header"></div>

<main class="content" aria-live="polite">
  <section class="film-card" id="episode-root">
    <div class="episode-header-row episode-header">
      <div class="episode-title-block">
        <div class="episode-title-meta-row">
          <h1 class="detail-title" id="episode-title">Loading episode‚Ä¶</h1>
          <p class="meta-line" id="episode-podcasted">Podcasted: ‚Äî</p>
        </div>
      </div>
      <div class="rosette-stack" aria-label="Episode rosettes" id="episode-rosettes"></div>
    </div>

    <div class="episode-grid">
      <div class="episode-poster">
        <img class="poster" id="episode-poster" src="" alt="" hidden />
      </div>
      <section class="episode-player" id="episode-player-container" aria-label="Player panel">
        <p class="episode-status" id="episode-player-status">Loading player‚Ä¶</p>
      </section>
      <div class="score-row episode-scores" data-score-row id="episode-score-row" data-kev-score="" data-audience-score="">
        <div class="score-card score-card--stat" data-score-card="kev">
          <div class="score-stat" data-score-half="kev">
            <div class="score-label">KEV‚ÄôS SCORE</div>
            <div class="score-value" data-score-value id="episode-kev-score">‚Äî</div>
          </div>
        </div>
        <div class="score-card score-card--stat" data-score-card="audience">
          <div class="score-stat" data-score-half="audience">
            <div class="score-label">LISTENER SCORE</div>
            <div class="score-value" data-score-value id="episode-listener-score">‚Äî</div>
          </div>
        </div>
      </div>
      <p class="episode-desc" id="episode-summary"></p>
    </div>

    <div class="episode-footer-row">
      <a class="back-link" href="/index.html">‚Üê Back to films</a>
    </div>
  </section>
</main>

<div id="site-footer"></div>

<script src="/assets/js/shared.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
  const headerContainer = document.getElementById("site-header");
  fetch("/assets/header.html")
    .then((response) => response.text())
    .then((html) => {
      headerContainer.innerHTML = html;
      const activePath = window.location.pathname === "/" ? "/index.html" : window.location.pathname;
      const navLinks = headerContainer.querySelectorAll(".nav-links a");
      navLinks.forEach((link) => {
        if (link.getAttribute("href") === activePath) {
          link.classList.add("active");
        }
      });
    })
    .catch((error) => {
      console.error("Failed to load header:", error);
    });

  const footerContainer = document.getElementById("site-footer");
  fetch("/assets/footer.html")
    .then((response) => response.text())
    .then((html) => {
      footerContainer.innerHTML = html;
    })
    .catch((error) => {
      console.error("Failed to load footer:", error);
    });
</script>

<script type="module">
import { loadFilmsData } from "/assets/js/films-data.js";

const BUZZSPROUT_HOST = "www.buzzsprout.com";
const SUPABASE_URL = "https://johklrouorflqfmzpiaw.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpvaGtscm91b3JmbHFmbXpwaWF3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk5NzgzNDQsImV4cCI6MjA4NTU1NDM0NH0.28kgIYh_BW-Ok2EHtxvm0NZM4e_0k2HzSFN0bkj9NPw";
const supabaseClient = window.supabase?.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const INSIGHT_MIN_VOTES = 1;
const INSIGHT_GAP_MIN = 1;
const INSIGHT_DIV_MIN = 1;
const audienceScores = {};
let allFilms = [];

const titleEl = document.getElementById("episode-title");
const podcastedEl = document.getElementById("episode-podcasted");
const rosettesEl = document.getElementById("episode-rosettes");
const posterEl = document.getElementById("episode-poster");
const summaryEl = document.getElementById("episode-summary");
const playerContainerEl = document.getElementById("episode-player-container");
const playerStatusEl = document.getElementById("episode-player-status");
const kevScoreEl = document.getElementById("episode-kev-score");
const listenerScoreEl = document.getElementById("episode-listener-score");

const AWARDS = [
  {
    key: "kev-pick",
    label: "Kev‚Äôs Pick",
    emoji: "üèÜ",
    rosetteClass: "rosette--kev-pick",
    description: "Awarded to the film that Kev loves the most.",
    getWinners: (films, aggregates) => {
      let topKevRating = null;
      const tiedFilms = [];
      films.forEach((film) => {
        const kevRating = getKevRating10(film, aggregates);
        const normalisedKevRating = normaliseScoreToPercent(kevRating);
        if (!Number.isFinite(normalisedKevRating)) return;
        if (topKevRating === null || normalisedKevRating > topKevRating) {
          topKevRating = normalisedKevRating;
          tiedFilms.length = 0;
          tiedFilms.push(film);
          return;
        }
        if (normalisedKevRating === topKevRating) tiedFilms.push(film);
      });
      if (tiedFilms.length <= 1) return tiedFilms;
      tiedFilms.sort((a, b) => {
        const aDate = parseTimestamp(a?.podcastDate)?.getTime() ?? null;
        const bDate = parseTimestamp(b?.podcastDate)?.getTime() ?? null;
        const aHasDate = Number.isFinite(aDate);
        const bHasDate = Number.isFinite(bDate);
        if (aHasDate && bHasDate && aDate !== bDate) return aDate - bDate;
        if (aHasDate !== bHasDate) return aHasDate ? -1 : 1;
        return String(a?.id ?? "").localeCompare(String(b?.id ?? ""));
      });
      return [tiedFilms[0]];
    }
  },
  {
    key: "listener-pick",
    label: "Listener Pick",
    emoji: "‚ù§Ô∏è",
    rosetteClass: "rosette--listener-pick",
    description: "Awarded to the film that listeners can't live without.",
    getWinners: (films, aggregates) => getTopAwardWinners(films, (film) => {
      const listenerAvg = getListenerAverage10(film, aggregates);
      const listenerCount = getListenerCount(film, aggregates);
      if (!Number.isFinite(listenerAvg) || listenerCount <= 0) return null;
      return listenerAvg;
    })
  },
  {
    key: "new",
    label: "New",
    emoji: "üÜï",
    rosetteClass: "rosette--new",
    description: "The most recently podcasted film.",
    getWinners: (films) => getTopAwardWinners(films, (film) => {
      const newest = getNewestFilmTimestamp(film);
      return Number.isFinite(newest) ? newest : null;
    })
  },
  {
    key: "most-underrated",
    label: "Most Underrated",
    emoji: "‚¨ÜÔ∏è",
    rosetteClass: "rosette--most-underrated",
    description: "Largest positive listener gap over Kev.",
    getWinners: (films, aggregates) => getBestSingleWinner(
      films,
      (film) => {
        const listenerAvg = getListenerAverage10(film, aggregates);
        const kevRating = getKevRating10(film, aggregates);
        const listenerCount = getListenerCount(film, aggregates);
        if (listenerCount < INSIGHT_MIN_VOTES || !Number.isFinite(listenerAvg) || !Number.isFinite(kevRating)) return null;
        const gap = listenerAvg - kevRating;
        return gap >= INSIGHT_GAP_MIN / 10 ? gap : null;
      },
      (film) => getListenerCount(film, aggregates)
    )
  },
  {
    key: "most-overrated",
    label: "Most Overrated",
    emoji: "‚¨áÔ∏è",
    rosetteClass: "rosette--most-overrated",
    description: "Largest positive Kev gap over listeners.",
    getWinners: (films, aggregates) => getBestSingleWinner(
      films,
      (film) => {
        const listenerAvg = getListenerAverage10(film, aggregates);
        const kevRating = getKevRating10(film, aggregates);
        const listenerCount = getListenerCount(film, aggregates);
        if (listenerCount < INSIGHT_MIN_VOTES || !Number.isFinite(listenerAvg) || !Number.isFinite(kevRating)) return null;
        const gap = kevRating - listenerAvg;
        return gap >= INSIGHT_GAP_MIN / 10 ? gap : null;
      },
      (film) => getListenerCount(film, aggregates)
    )
  },
  {
    key: "most-divisive",
    label: "Most Divisive",
    emoji: "‚ö°",
    rosetteClass: "rosette--most-divisive",
    description: "Awarded to the film with biggest rating variance.",
    getWinners: (films, aggregates) => getBestSingleWinnerWithTiebreak(
      films,
      (film) => {
        const listenerCount = getListenerCount(film, aggregates);
        if (listenerCount < INSIGHT_MIN_VOTES) return null;
        const metric = getDivisiveAwardMetric(film, aggregates);
        return Number.isFinite(metric) && metric >= INSIGHT_DIV_MIN ? metric : null;
      },
      (film) => getListenerCount(film, aggregates),
      (film) => {
        const listenerAvg10 = getListenerAverage10(film, aggregates);
        const kevAvg10 = getKevRating10(film, aggregates);
        const gapVsKev = Number.isFinite(listenerAvg10) && Number.isFinite(kevAvg10)
          ? Math.abs(listenerAvg10 - kevAvg10)
          : -1;
        return { gapVsKev, title: String(film.title || "") };
      }
    )
  },
  {
    key: "lost-plot",
    label: "Lost the Plot",
    emoji: "üåÄ",
    rosetteClass: "rosette--lost-plot",
    description: "Furthest from the real film.",
    shouldDisplay: (films, aggregates) => films.some((film) => Number.isFinite(getRottenTomatoesScore10(film, aggregates))),
    getWinners: (films, aggregates) => getBestSingleWinner(
      films,
      (film) => {
        const kevRating = getKevRating10(film, aggregates);
        const listenerAvg = getListenerAverage10(film, aggregates);
        const rottenScore = getRottenTomatoesScore10(film, aggregates);
        if (!Number.isFinite(kevRating) || !Number.isFinite(listenerAvg) || !Number.isFinite(rottenScore)) return null;
        return (Math.abs(kevRating - rottenScore) + Math.abs(listenerAvg - rottenScore)) / 2;
      },
      (film) => getListenerCount(film, aggregates)
    )
  },
  {
    key: "fixed-it",
    label: "Fixed It",
    emoji: "‚ú®",
    rosetteClass: "rosette--fixed-it",
    description: "Kev‚Äôs score beats Rotten Tomatoes for the real film.",
    getWinners: (films, aggregates) => films.filter((film) => {
      const kevRating = getKevRating10(film, aggregates);
      const rottenScore = getRottenTomatoesScore10(film, aggregates);
      if (!Number.isFinite(kevRating) || !Number.isFinite(rottenScore)) return false;
      return kevRating > rottenScore;
    })
  },
  {
    key: "consensus-achieved",
    label: "Consensus Achieved",
    emoji: "ü§ù",
    rosetteClass: "rosette--consensus",
    description: "Kev and listeners agreed the most.",
    getWinners: (films, aggregates) => getBestSingleWinnerLowest(
      films,
      (film) => {
        const kevRating = getKevRating10(film, aggregates);
        const listenerAvg = getListenerAverage10(film, aggregates);
        if (!Number.isFinite(kevRating) || !Number.isFinite(listenerAvg)) return null;
        return Math.abs(kevRating - listenerAvg);
      },
      (film) => getListenerCount(film, aggregates)
    )
  }
];

function parseLocalDate(d) {
  if (!d) return null;
  const [year, month, day] = String(d).split("-").map(Number);
  if (!year || !month || !day) return null;
  const dt = new Date(year, month - 1, day);
  return Number.isNaN(dt.getTime()) ? null : dt;
}

function parseTimestamp(value) {
  if (!value) return null;
  if (value instanceof Date) return Number.isNaN(value.getTime()) ? null : value;
  if (typeof value === "number") {
    const numericDate = new Date(value);
    return Number.isNaN(numericDate.getTime()) ? null : numericDate;
  }
  if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) return null;
    if (/^\d{2}\/\d{2}\/\d{2}$/.test(trimmed)) {
      const [day, month, shortYear] = trimmed.split("/").map(Number);
      const fullYear = 2000 + shortYear;
      const ukShortDate = new Date(fullYear, month - 1, day);
      return Number.isNaN(ukShortDate.getTime()) ? null : ukShortDate;
    }
    const localDate = parseLocalDate(trimmed);
    if (localDate) return localDate;
    const isoLike = /^\d{4}-\d{2}-\d{2}T/.test(trimmed) || /^\d{4}-\d{2}-\d{2}$/.test(trimmed);
    if (!isoLike) return null;
    const parsed = new Date(trimmed);
    return Number.isNaN(parsed.getTime()) ? null : parsed;
  }
  return null;
}

function formatUkDate(d) {
  const dt = parseLocalDate(d) || parseTimestamp(d);
  return dt ? dt.toLocaleDateString("en-GB").replaceAll("/", "-") : (d || "‚Äî");
}

function formatPodcastDateDisplay(podcastDate) {
  const parsed = parseLocalDate(podcastDate);
  if (!parsed) return podcastDate || "‚Äî";
  return new Intl.DateTimeFormat("en-GB", {
    day: "2-digit",
    month: "short",
    year: "numeric"
  }).format(parsed);
}

function escapeHtml(value) {
  return String(value)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;");
}

function getPercentRaw(value) {
  const score = Number(value);
  return Number.isFinite(score) ? score : null;
}

function roundPercent(value) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed)) return null;
  return Math.round(parsed);
}

function formatPercentLabel(value) {
  const rounded = roundPercent(value);
  return rounded === null ? "‚Äî" : `${rounded}%`;
}

function formatAudienceScore(value) {
  const score = getPercentRaw(value);
  if (score === null) return null;
  return roundPercent(score);
}

function normaliseScoreToPercent(value) {
  const score = Number(value);
  if (!Number.isFinite(score)) return null;
  if (score >= 0 && score <= 10) return score * 10;
  if (score >= 0 && score <= 100) return score;
  return null;
}

function getListenerCount(film, aggregates = {}) {
  const audienceData = aggregates.audienceScores?.[film.id] ?? audienceScores[film.id];
  const listenerVotesRaw = audienceData?.listener_count
    ?? film.listenerVotes
    ?? (Array.isArray(film.listenerRatings) ? film.listenerRatings.length : null);
  const listenerVotes = Number(listenerVotesRaw);
  return Number.isFinite(listenerVotes) ? listenerVotes : 0;
}

function getListenerAverage10(film, aggregates = {}) {
  const audienceData = aggregates.audienceScores?.[film.id] ?? audienceScores[film.id];
  const weightedPercent = audienceData?.weighted_percent
    ?? film.listenerScore
    ?? film.listenerRating
    ?? film.listenerPercent
    ?? film.listener_score;
  const normalized = normaliseScoreToPercent(weightedPercent);
  return normalized !== null ? normalized / 10 : null;
}

function getKevRating10(film, _aggregates = {}) {
  const kevValue = film.kev_rating_10 ?? film.kevRating10 ?? film.kevScore ?? film.score;
  const normalized = normaliseScoreToPercent(kevValue);
  if (normalized !== null) return normalized / 10;
  return getRobComponentAverage10(film);
}

function getRobComponentAverage10(film) {
  const coherence = Number(film.coherence ?? film.coherenceScore ?? film.coherence_rating);
  const entertainment = Number(film.entertainment ?? film.entertainmentScore ?? film.entertainment_rating);
  const originality = Number(film.originality ?? film.originalityScore ?? film.originality_rating);
  if (![coherence, entertainment, originality].every((value) => Number.isFinite(value) && value >= 0 && value <= 10)) {
    return null;
  }
  return (coherence + entertainment + originality) / 3;
}

function normalizeFilmTitle(value) {
  return String(value || "").trim().toLowerCase();
}

function findMatchingRealFilm(film, films = []) {
  if (!film?.title) return null;
  const targetTitle = normalizeFilmTitle(film.title);
  return films.find((candidate) => !candidate.rob && normalizeFilmTitle(candidate.title) === targetTitle) ?? null;
}

function getRottenTomatoesScore10FromFilm(film) {
  if (!film) return null;
  const directValue = film.rottenTomatoesScore ?? film.rtScore ?? film.rt_score ?? film.rotten_score;
  const directNormalized = normaliseScoreToPercent(directValue);
  if (directNormalized !== null) return directNormalized / 10;
  const scoreLabel = String(film.scoreLabel || "");
  if (!film.rob && scoreLabel.toLowerCase().includes("rotten")) {
    const normalized = normaliseScoreToPercent(film.score);
    return normalized !== null ? normalized / 10 : null;
  }
  return null;
}

function getRottenTomatoesScore10(film, aggregates = {}) {
  const direct = getRottenTomatoesScore10FromFilm(film);
  if (direct !== null) return direct;
  const allFilmsList = aggregates.allFilms ?? allFilms;
  if (!Array.isArray(allFilmsList)) return null;
  const matched = findMatchingRealFilm(film, allFilmsList);
  return matched ? getRottenTomatoesScore10FromFilm(matched) : null;
}

function getNewestFilmTimestamp(film) {
  const dateValue = film.podcasted_at ?? film.podcastedAt ?? film.podcastDate ?? film.created_at ?? film.createdAt ?? film.published_at ?? film.publishedAt ?? film.date;
  const parsed = parseTimestamp(dateValue);
  return parsed ? parsed.getTime() : null;
}

function computeStandardDeviation(values) {
  const parsed = values.map((value) => Number(value)).filter((value) => Number.isFinite(value));
  if (parsed.length < 2) return null;
  const mean = parsed.reduce((sum, value) => sum + value, 0) / parsed.length;
  const variance = parsed.reduce((sum, value) => sum + ((value - mean) ** 2), 0) / parsed.length;
  return Math.sqrt(variance);
}

function getDivisiveMetric(film, aggregates = {}) {
  const audienceData = aggregates.audienceScores?.[film.id] ?? audienceScores[film.id] ?? {};
  const listenerRatings = Array.isArray(film.listenerRatings)
    ? film.listenerRatings
    : (Array.isArray(audienceData.listener_ratings) ? audienceData.listener_ratings : null);

  if (listenerRatings?.length >= 2) {
    const normalisedRatings = listenerRatings.map(normaliseScoreToPercent).filter((value) => Number.isFinite(value));
    if (normalisedRatings.length >= 2) return computeStandardDeviation(normalisedRatings);
  }

  const spreadRaw = audienceData.rating_spread ?? film.ratingSpread ?? film.listenerRatingSpread;
  const spreadNorm = normaliseScoreToPercent(spreadRaw);
  if (spreadNorm !== null) return spreadNorm;

  const minRating = normaliseScoreToPercent(audienceData.min_rating ?? film.listenerMinRating ?? film.listenerRatingMin);
  const maxRating = normaliseScoreToPercent(audienceData.max_rating ?? film.listenerMaxRating ?? film.listenerRatingMax);
  if (minRating !== null && maxRating !== null && maxRating >= minRating) return maxRating - minRating;

  return null;
}

function getDivisiveAwardMetric(film, aggregates = {}) {
  const audienceData = aggregates.audienceScores?.[film.id] ?? audienceScores[film.id] ?? {};
  const hasPerVoteRatings = Array.isArray(film.listenerRatings) || Array.isArray(audienceData.listener_ratings);
  const baseSpread = getDivisiveMetric(film, aggregates);
  if (!Number.isFinite(baseSpread)) return null;
  if (hasPerVoteRatings) return baseSpread;
  const listenerCount = getListenerCount(film, aggregates);
  return listenerCount > 0 ? baseSpread * listenerCount : baseSpread;
}

function getTopAwardWinners(films, getValue) {
  let bestValue = null;
  let winners = [];
  films.forEach((film) => {
    const value = getValue(film);
    if (!Number.isFinite(value)) return;
    if (bestValue === null || value > bestValue) {
      bestValue = value;
      winners = [film];
      return;
    }
    if (value === bestValue) winners.push(film);
  });
  return winners;
}

function getBestSingleWinner(films, getMetric, getVotes) {
  let bestFilm = null;
  let bestMetric = null;
  let bestVotes = null;
  let bestTitle = "";
  films.forEach((film) => {
    const metric = getMetric(film);
    if (!Number.isFinite(metric)) return;
    const safeVotes = Number(getVotes(film)) || 0;
    const title = String(film.title || "");
    if (bestFilm === null || metric > bestMetric || (metric === bestMetric && safeVotes > bestVotes) || (metric === bestMetric && safeVotes === bestVotes && title.localeCompare(bestTitle, "en-GB", { sensitivity: "base" }) < 0)) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestTitle = title;
    }
  });
  return bestFilm ? [bestFilm] : [];
}

function getBestSingleWinnerWithTiebreak(films, getMetric, getVotes, getTie) {
  let bestFilm = null;
  let bestMetric = null;
  let bestVotes = null;
  let bestGap = -1;
  let bestTitle = "";
  films.forEach((film) => {
    const metric = getMetric(film);
    if (!Number.isFinite(metric)) return;
    const safeVotes = Number(getVotes(film)) || 0;
    const tieData = getTie ? getTie(film) : {};
    const gapVsKev = Number.isFinite(tieData?.gapVsKev) ? tieData.gapVsKev : -1;
    const title = String(tieData?.title ?? film.title ?? "");
    if (bestFilm === null
      || metric > bestMetric
      || (metric === bestMetric && gapVsKev > bestGap)
      || (metric === bestMetric && gapVsKev === bestGap && safeVotes > bestVotes)
      || (metric === bestMetric && gapVsKev === bestGap && safeVotes === bestVotes && title.localeCompare(bestTitle, "en-GB", { sensitivity: "base" }) < 0)) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestGap = gapVsKev;
      bestTitle = title;
    }
  });
  return bestFilm ? [bestFilm] : [];
}

function getBestSingleWinnerLowest(films, getMetric, getVotes) {
  let bestFilm = null;
  let bestMetric = null;
  let bestVotes = null;
  let bestTitle = "";
  films.forEach((film) => {
    const metric = getMetric(film);
    if (!Number.isFinite(metric)) return;
    const safeVotes = Number(getVotes(film)) || 0;
    const title = String(film.title || "");
    if (bestFilm === null
      || metric < bestMetric
      || (metric === bestMetric && safeVotes > bestVotes)
      || (metric === bestMetric && safeVotes === bestVotes && title.localeCompare(bestTitle, "en-GB", { sensitivity: "base" }) < 0)) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestTitle = title;
    }
  });
  return bestFilm ? [bestFilm] : [];
}

function getVisibleAwards(films, aggregates = {}) {
  return AWARDS.filter((award) => typeof award.shouldDisplay !== "function" || award.shouldDisplay(films, aggregates));
}

function isValidBuzzsproutScriptSrc(value) {
  if (!value || typeof value !== "string") return false;
  try {
    const url = new URL(value);
    if (url.protocol !== "https:" || url.hostname !== BUZZSPROUT_HOST) return false;
    if (!/^\/\d+\/episodes\/\d+-.+\.js$/.test(url.pathname)) return false;
    return url.searchParams.get("player") === "small";
  } catch {
    return false;
  }
}


function getRosettesForFilm(film) {
  const rosettes = [{ className: film.rob ? "rob" : "real", label: film.rob ? "Rob‚Äôs Film" : "Real Film", icon: "" }];

  if (film.rob) {
    const robFilmsAll = allFilms.filter((entry) => entry.active && entry.rob);
    const awardsContext = { audienceScores, allFilms };
    const visibleAwards = getVisibleAwards(robFilmsAll, awardsContext);
    const awardWinnersByKey = Object.fromEntries(
      visibleAwards.map((award) => [award.key, new Set(award.getWinners(robFilmsAll, awardsContext).map((winner) => winner.id))])
    );

    visibleAwards.forEach((award) => {
      if (!awardWinnersByKey[award.key]?.has(film.id)) return;
      rosettes.push({
        className: award.rosetteClass,
        label: award.label,
        icon: `<span class="badge-icon" aria-hidden="true">${award.emoji}</span>`,
        title: award.description || ""
      });
    });
  }

  if (Array.isArray(film.rosettes)) {
    film.rosettes.forEach((rosette) => {
      if (!rosette?.label) return;
      rosettes.push({ className: rosette.className || "other", label: rosette.label, icon: rosette.icon || "", title: rosette.title || "" });
    });
  }

  rosettesEl.innerHTML = rosettes.map(({ className, label, icon, title }) => {
    const iconMarkup = icon ? ` ${icon.trim()}` : "";
    return `<span class="rosette ${className}"${title ? ` title="${escapeHtml(title)}"` : ""}>${label}${iconMarkup}</span>`;
  }).join("");
}

function renderPlayer(film) {
  playerStatusEl.textContent = "Audio coming soon.";
  const scriptSrc = typeof film?.buzzsproutScriptSrc === "string" ? film.buzzsproutScriptSrc.trim() : "";
  if (!isValidBuzzsproutScriptSrc(scriptSrc)) {
    playerContainerEl.replaceChildren(playerStatusEl);
    return;
  }

  const parsedSrc = new URL(scriptSrc);
  const playerContainerId = `buzzsprout-player-${String(film.id || "episode").replace(/[^a-zA-Z0-9_-]/g, "-")}`;
  parsedSrc.searchParams.set("container_id", playerContainerId);
  parsedSrc.searchParams.set("player", "small");

  const mount = document.createElement("div");
  mount.id = playerContainerId;
  playerContainerEl.replaceChildren(mount);

  const script = document.createElement("script");
  script.src = parsedSrc.toString();
  script.type = "text/javascript";
  script.async = true;
  script.charset = "utf-8";
  script.onerror = () => {
    playerContainerEl.replaceChildren(playerStatusEl);
  };
  playerContainerEl.appendChild(script);
}

function showNotFoundState() {
  titleEl.textContent = "Episode not found";
  podcastedEl.textContent = "Podcasted: ‚Äî";
  summaryEl.textContent = "We couldn't find that episode. Please return to the films list and choose another episode.";
  rosettesEl.innerHTML = "";
  playerStatusEl.textContent = "Audio coming soon.";
  playerContainerEl.replaceChildren(playerStatusEl);
  posterEl.hidden = true;
}

async function fetchAudienceScoresForFilms(_films = []) {
  if (!supabaseClient) return;

  const { data, error } = await supabaseClient
    .from("film_scores_v1")
    .select("film_id, weighted_percent, listener_count");

  if (error) {
    console.error("Failed to fetch audience scores.", error);
    return;
  }

  data.forEach((row) => {
    audienceScores[row.film_id] = {
      weighted_percent: row.weighted_percent,
      listener_count: row.listener_count
    };
  });
}

async function fetchListenerVotesForFilms(films = []) {
  if (!supabaseClient) return;
  const robIds = films.filter((film) => film?.rob).map((film) => film.id).filter(Boolean);
  if (!robIds.length) return;

  const pageSize = 1000;
  let fromIndex = 0;
  while (true) {
    const toIndex = fromIndex + pageSize - 1;
    const { data, error } = await supabaseClient
      .from("film_votes")
      .select("film_id, rating")
      .in("film_id", robIds)
      .range(fromIndex, toIndex);

    if (error) {
      console.error("Failed to fetch listener votes.", error);
      return;
    }

    if (!data?.length) break;

    data.forEach((row) => {
      const existing = audienceScores[row.film_id] ?? {};
      const ratings = Array.isArray(existing.listener_ratings) ? existing.listener_ratings : [];
      ratings.push(row.rating);
      audienceScores[row.film_id] = { ...existing, listener_ratings: ratings };
    });

    if (data.length < pageSize) break;
    fromIndex += pageSize;
  }
}

function renderEpisode(film) {
  document.title = `${film.title} ‚Äì No Context Cinema Club`;
  titleEl.textContent = film.title || "Episode";
  podcastedEl.textContent = `Podcasted: ${formatPodcastDateDisplay(film.podcastDate)}`;
  summaryEl.textContent = film.summary || "";

  if (film.poster) {
    posterEl.src = film.poster;
    posterEl.alt = `Poster for ${film.title || "episode"}`;
    posterEl.hidden = false;
  } else {
    posterEl.hidden = true;
  }

  renderPlayer(film);
  getRosettesForFilm(film);

  if (!film?.id) {
    console.warn("Episode page film is missing an id, listener score lookup may fail.");
  }

  const kevRating10 = getKevRating10(film, { audienceScores }) ?? getRobComponentAverage10(film);
  const kevPercentRaw = kevRating10 !== null ? getPercentRaw(kevRating10 * 10) : null;
  const audiencePercentRaw = formatAudienceScore(audienceScores[film.id]?.weighted_percent);

  kevScoreEl.textContent = formatPercentLabel(kevPercentRaw);
  listenerScoreEl.textContent = formatPercentLabel(audiencePercentRaw);
}

async function initEpisodePage() {
  const params = new URLSearchParams(window.location.search);
  const id = params.get("id");

  if (!id) {
    showNotFoundState();
    return;
  }

  try {
    allFilms = await loadFilmsData();
    const film = allFilms.find((entry) => entry?.id === id);

    if (!film) {
      showNotFoundState();
      return;
    }

    await fetchAudienceScoresForFilms(allFilms);
    await fetchListenerVotesForFilms(allFilms);
    renderEpisode(film);
  } catch (error) {
    console.error("Failed to load episode", error);
    showNotFoundState();
  }
}

initEpisodePage();
</script>
</body>
</html>
