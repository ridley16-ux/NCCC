<!DOCTYPE html>
<html lang="en-GB">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BHEJTM2PGH"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-BHEJTM2PGH');
</script>

<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/icons/favicon-16x16.png">
<link rel="manifest" href="/assets/data/site.webmanifest">

<meta charset="UTF-8" />
<title>No Context Cinema Club â€“ Films</title>
<meta name="description" content="Explore No Context Cinema Club episodes: Robâ€™s alternate plots, real film matchups, and listener-voted favourites." />
<meta name="robots" content="index,follow" />
<link rel="canonical" href="https://nocontextcinemaclub.com/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="website-version" content="1.16.1" />
<meta property="og:title" content="No Context Cinema Club â€“ Films" />
<meta property="og:description" content="Explore No Context Cinema Club episodes: Robâ€™s alternate plots, real film matchups, and listener-voted favourites." />
<meta property="og:url" content="https://nocontextcinemaclub.com/" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://nocontextcinemaclub.com/assets/branding/podcast-cover.webp" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="No Context Cinema Club â€“ Films" />
<meta name="twitter:description" content="Explore No Context Cinema Club episodes: Robâ€™s alternate plots, real film matchups, and listener-voted s." />
<meta name="twitter:image" content="https://nocontextcinemaclub.com/assets/branding/podcast-cover.webp" />
<link rel="stylesheet" href="/assets/css/site.css" />
<script type="module">
  import { buildPodcastSeriesSchema, injectJsonLd } from "/assets/js/seo.js";

  injectJsonLd(
    "podcast-series-schema",
    buildPodcastSeriesSchema({
      pageTitle: "No Context Cinema Club â€“ Films",
      pageDescription: "Explore No Context Cinema Club episodes: Robâ€™s alternate plots, real film matchups, and listener-voted favourites.",
      pageUrl: "https://nocontextcinemaclub.com/"
    })
  );
</script>

<style>
:root {
  --bg: #0f0f0f;
  --card: #1b1b1b;
  --text: #ffffff;
  --muted: #aaaaaa;
  --line: rgba(255, 255, 255, 0.1);
  --accent-rt: #f5c56b;
  --accent-rob: #d46a2a;
  --brand-orange: var(--accent-rob);
}

* {
  font-family: inherit;
}

/* Prevent horizontal scroll (iOS/Safari friendly) */
html {
  overflow-x: visible;
  font-family: Arial, Helvetica, sans-serif;
}

/* Ensure padding/borders don't create overflow */
*, *::before, *::after { box-sizing: border-box; }

/* Any media should never exceed viewport */
img, video, canvas, svg {
  max-width: 100%;
  height: auto;
}

body {
  font-family: inherit;
  background: var(--bg);
  color: var(--text);
  margin: 0;
  padding: 0;
  overflow-x: hidden;     /* fallback */
  overflow-y: scroll;
  scrollbar-gutter: stable;
}

/* Prefer clip when supported (less likely to interfere with sticky) */
@supports (overflow: clip) {
  body {
    overflow-x: clip;
  }
}

button,
input,
select,
textarea,
option,
label {
  font-family: inherit;
  font-weight: inherit;
  font-style: inherit;
}

/* Filters + Sort */
.controls {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: stretch;
  gap: 8px;
  margin-bottom: 0;
  flex-wrap: wrap;
  width: 100%;
}

.filters-row {
  width: 100%;
  max-width: 900px;
  margin: 0 auto;
  padding: 0 16px;
}

.filter-row {
  display: flex;
  justify-content: center;
  align-items: flex-end;
  gap: 16px;
  flex-wrap: wrap;
}

.control-row {
  display: contents;
}

.filter-row .filter {
  order: 1;
}

.filter-row .sort {
  order: 2;
}

.filter-row .film-search-toggle {
  order: 3;
}

.filter {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
  min-width: 0;
}

.sort {
  flex: 0 0 auto;
  display: flex;
  align-items: center;
  gap: 6px;
}


.film-search-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  border: none;
  border-radius: 20px;
  padding: 10px 14px;
  background: #2c2c2c;
  color: #fff;
  cursor: pointer;
  font-size: 18px;
  line-height: 1;
}

.film-search-toggle-text {
  display: none;
}

.film-search-toggle-label {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

.film-search-toggle-icon {
  font-size: 16px;
  line-height: 1;
}

.film-search-toggle-icon--search {
  display: none;
}

.film-search-toggle.is-active,
.film-search-toggle.has-filters {
  background: #383838;
}

.film-search-row {
  max-height: 0;
  opacity: 0;
  overflow: hidden;
  pointer-events: none;
  transition: max-height 0.25s ease, opacity 0.2s ease;
}

.film-search-row.is-open {
  max-height: 80px;
  opacity: 1;
  pointer-events: auto;
}

.film-search-wrap {
  position: relative;
}

.search-field {
  position: relative;
}

#filmSearchRow .film-search-input[type="search"] {
  -webkit-appearance: none;
  appearance: none;
}

#filmSearchRow .film-search-input[type="search"]::-webkit-search-cancel-button {
  -webkit-appearance: none;
  display: none;
}

#filmSearchRow .film-search-input[type="search"]::-webkit-search-decoration,
#filmSearchRow .film-search-input[type="search"]::-webkit-search-results-button,
#filmSearchRow .film-search-input[type="search"]::-webkit-search-results-decoration {
  display: none;
}

.search-clear {
  position: absolute;
  top: 50%;
  right: 2px;
  transform: translateY(-50%);
  width: 40px;
  height: 40px;
  border: 0;
  padding: 0;
  border-radius: 999px;
  background: transparent;
  color: rgba(255, 255, 255, 0.55);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  line-height: 1;
  cursor: pointer;
}

.search-clear:hover,
.search-clear:focus-visible,
.search-clear:active {
  color: rgba(255, 255, 255, 0.9);
}

.search-clear[hidden] {
  display: none;
}

.search-icon,
.select-icon {
  display: none;
}

.film-search-input {
  width: 100%;
  background: #2c2c2c;
  color: #fff;
  border: 2px solid #3f3f3f;
  border-radius: 20px;
  padding: 0 14px;
  height: 44px;
  min-height: 44px;
  box-sizing: border-box;
  font-size: 16px;
  line-height: 1.2;
  padding-right: 52px;
}

.film-search-input:hover {
  border-color: rgba(255, 255, 255, 0.28);
}

.film-search-input:focus,
.film-search-input:focus-visible,
.film-search-input:active {
  outline: none;
  box-shadow: none;
  border-color: #d46a2a;
}

.film-search-suggestions {
  margin-top: 6px;
  color: var(--muted);
  font-size: 12px;
}

.filter label,
.sort label,
.film-search-wrap label {
  font-size: 13px;
  color: var(--muted);
}

.filter select,
.sort select {
  white-space: nowrap;
}

.filter select,
.sort select {
  background: #2c2c2c;
  color: #fff;
  border: 1px solid rgba(255, 255, 255, 0.1);
  padding: 0 14px;
  height: 44px;
  min-height: 44px;
  box-sizing: border-box;
  border-radius: 20px;
  font-weight: bold;
  cursor: pointer;
  font-size: 16px;
}

/* Film list */
.films-list {
  max-width: 900px;
  margin: 0 auto;
  padding-top: 10px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.film-card {
  display: block;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), transparent 55%), var(--card);
  border-radius: 18px;
  border: 1px solid var(--line);
  padding: 18px;
  position: relative;
  box-shadow: 0 18px 60px rgba(0, 0, 0, 0.45);
  --rosette-pocket-right: 18px;
  --poster-side-offset: 18px;
  --badge-above-poster-gap: 8px;
}

.film-card.rob-film {
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), transparent 55%), #2a2a2a;
}

:root {
  --badge-height: 30px;
  --badge-font-size: 15px;
  --badge-padding-x: 12px;
  --badge-radius: 999px;
  --badge-row-top: 16px;
  --badge-row-gap-desktop: 10px;
  --badge-row-gap-mobile: 8px;
}

.hero-rank {
  position: absolute;
  top: calc(var(--poster-side-offset) - var(--badge-height) - var(--badge-above-poster-gap));
  left: var(--poster-side-offset);
  background: gold;
  color: #000;
  min-height: var(--badge-height);
  padding: 0 var(--badge-padding-x);
  border-radius: var(--badge-radius);
  font-size: var(--badge-font-size);
  font-weight: 900;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  z-index: 5;
}

.flag {
  text-transform: uppercase;
}
.flag.rob { background: #3e5f3e; color: #d8f0d8; }
.flag.real { background: #444; color: #fff; }

.hero-layout {
  display: grid;
  grid-template-columns: minmax(220px, 260px) minmax(0, 1fr);
  gap: 18px;
  align-items: start;
  padding-top: 0;
}

.film-poster-wrapper {
  position: relative;
  width: 100%;
  max-width: 260px;
}

.poster-wrap {
  position: relative;
  width: 100%;
  max-width: 260px;
}

.rosette-stack {
  position: absolute;
  top: calc(var(--poster-side-offset) - var(--badge-height) - var(--badge-above-poster-gap) + 2px);
  right: var(--poster-side-offset);
  display: flex;
  flex-direction: row;
  align-items: flex-end;
  gap: 6px;
  z-index: 4;
  pointer-events: none;
  white-space: nowrap;
  flex-wrap: nowrap;
}

.poster {
  width: 100%;
  max-width: 260px;
  height: auto;
  object-fit: cover;
  border-radius: 8px;
  display: block;
  position: relative;
  z-index: 1;
}

.film-details {
  flex: 1;
  min-width: 0;
}

.detail-row {
  display: grid;
  grid-template-columns: 1fr minmax(220px, 320px);
  gap: 14px;
  align-items: start;
  min-width: 0;
}

/* âœ… wider Kev badge column on Rob cards */
.rob-details .detail-row {
  grid-template-columns: minmax(0, 1.8fr) minmax(200px, 340px);
}

.rob-details .detail-row > :first-child {
  max-width: 150%;
}

.rob-details .score-row {
  height: 100%;
  align-items: center;
  justify-content: center;
}

.rob-details .score-card--stat {
  width: 100%;
}

.detail-title {
  margin: 0;
  font-size: 28px;
  letter-spacing: -0.02em;
  line-height: 1.15;
  overflow-wrap: anywhere;
}

.meta-line {
  margin: 8px 0 0;
  font-size: 14px;
  color: var(--muted);
}

.meta-line + .meta-line { margin-top: 4px; }

.audience-score {
  margin-top: 8px;
  display: flex;
  flex-direction: column;
  gap: 2px;
  font-size: 13px;
  color: rgba(255, 255, 255, 0.72);
}

.audience-line {
  margin: 0;
}

[data-audience-votes] {
  display: none;
}

.audience-line.audience-nudge {
  animation: audienceNudge 1.4s ease-out;
}

@keyframes audienceNudge {
  0% {
    background: rgba(191, 232, 191, 0.28);
    color: #e9ffef;
  }
  100% {
    background: transparent;
    color: rgba(255, 255, 255, 0.72);
  }
}

.variant {
  color: #bfe8bf;
  font-weight: 800;
}

.dot { opacity: 0.7; }

.score-row {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  align-items: stretch;
  gap: 12px;
  min-width: 0;
}

.score-card {
  border-radius: 18px;
  padding: 14px;
}

.score-card--stat {
  min-width: 0;
  border: 1px solid rgba(124, 74, 45, 0.88);
  background: rgba(92, 54, 31, 0.8);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06);
}

.score-stat {
  height: 100%;
  display: flex;
  flex-direction: column;
  gap: 6px;
  min-width: 0;
  align-items: center;
  text-align: center;
}

.score-label {
  font-size: 12px;
  font-weight: 800;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: rgba(255, 255, 255, 0.86);
}

.score-value {
  font-size: 30px;
  font-weight: 900;
  line-height: 1;
}

.score-trend {
  margin-left: 0.32em;
  font-size: 0.9em;
  line-height: 1;
}

.score-trend--up {
  color: #8ddf9f;
}

.score-trend--down {
  color: #ff8e86;
}

.rosette {
  font-size: 11px;
  font-weight: 700;
  padding: 6px 12px;
  border-radius: 999px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  white-space: nowrap;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.18), 0 2px 8px rgba(0, 0, 0, 0.45);
  color: #fff;
}

.badge-icon {
  font-size: 0.9em;
  line-height: 1;
}

.badge {
  border-radius: 18px;
  padding: 14px;
}

.badge-label {
  font-size: 12px;
  font-weight: 800;
  letter-spacing: 0.08em;
  text-transform: uppercase;
}

.badge-value {
  font-size: 34px;
  font-weight: 900;
  margin-top: 6px;
  line-height: 1;
  display: flex;
  align-items: center;
  gap: 8px;
}

.rt-badge {
  border: 1px solid rgba(245, 197, 107, 0.35);
  background: rgba(245, 197, 107, 0.14);
}
.rt-badge .badge-label { color: #ffe4b3; }

.kev-badge {
  border: 1px solid #e08a58;
  background: rgba(212, 106, 42, 0.4);
}
.kev-badge .badge-label { color: #ffd7bf; }

.rosette.rob { background: #3e5f3e; color: #d8f0d8; }
.rosette.real { background: #444; color: #fff; }
.rosette--kev-pick { background: var(--rosette-kev-pick); }
.rosette--listener-pick { background: var(--rosette-listener-pick); }
.rosette--new { background: var(--rosette-new); }
.rosette.other { background: #565656; }
.rosette--most-underrated { background: var(--rosette-most-underrated); }
.rosette--most-overrated { background: var(--rosette-most-overrated); }
.rosette--most-divisive { background: var(--rosette-most-divisive); }
.rosette--lost-plot { background: var(--rosette-lost-plot-bg); }
.rosette--fixed-it { background: var(--rosette-fixed-it-bg); }
.rosette--consensus { background: var(--rosette-consensus-bg); }

.divider {
  height: 1px;
  background: var(--line);
  margin: 16px 0;
}

.synopsis {
  line-height: 1.63;
  font-size: 16px;
  color: rgba(255, 255, 255, 0.92);
  overflow-wrap: anywhere;
}

.cta {
  margin-top: 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
}

.cta > * { min-width: 0; }

.cta-actions {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 6px;
}

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 12px 16px;
  border-radius: 14px;
  border: 1px solid rgba(0, 0, 0, 0.2);
  font-weight: 800;
  text-decoration: none;
}

.btn.rt {
  background: var(--accent-rt);
  color: #000;
  box-shadow: 0 10px 24px rgba(245, 197, 107, 0.25);
}

.btn.podcast {
  background: var(--accent-rob);
  color: #fff;
  box-shadow: 0 10px 24px rgba(212, 106, 42, 0.22);
}

.btn:focus {
  outline: 3px solid rgba(245, 197, 107, 0.45);
  outline-offset: 2px;
}
.btn.podcast:focus { outline-color: rgba(212, 106, 42, 0.35); }

.button {
  position: relative;
  transition: all 0.3s ease-in-out;
  box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.2);
  padding-block: 0.5rem;
  padding-inline: 1.25rem;
  background-color: var(--brand-orange);
  border-radius: 9999px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #ffffff;
  gap: 10px;
  font-weight: bold;
  border: 3px solid rgba(255, 255, 255, 0.3);
  outline: none;
  overflow: hidden;
  font-size: 15px;
  text-decoration: none;
}

.button:hover {
  transform: scale(1.05);
  border-color: rgba(255, 255, 255, 0.6);
}

.button:focus-visible {
  outline: 3px solid rgba(255, 255, 255, 0.7);
  outline-offset: 3px;
}

.button::before {
  content: "";
  position: absolute;
  width: 100px;
  height: 100%;
  background-image: linear-gradient(
    120deg,
    rgba(255, 255, 255, 0) 30%,
    rgba(255, 255, 255, 0.8),
    rgba(255, 255, 255, 0) 70%
  );
  top: 0;
  left: -100px;
  opacity: 0.6;
}

.button:hover::before {
  animation: shine 1.5s ease-out infinite;
}

@keyframes shine {
  0% { left: -100px; }
  60% { left: 100%; }
  100% { left: 100%; }
}

.transcript-link {
  appearance: none;
  background: none;
  border: none;
  padding: 0;
  color: rgba(255, 255, 255, 0.78);
  font-size: 14px;
  font-weight: 600;
  text-decoration: underline;
  cursor: pointer;
  transition: color 0.2s ease;
}

.transcript-link:hover,
.transcript-link:focus-visible {
  color: #ffffff;
}

.transcript-link:focus-visible {
  outline: 2px solid rgba(255, 255, 255, 0.6);
  outline-offset: 3px;
  border-radius: 6px;
}

.listener-score {
  margin: 8px 0 0;
  font-size: 14px;
  color: #fff;
  display: flex;
  align-items: center;
  gap: 6px;
}

.listener-info-wrap {
  position: relative;
  display: inline-flex;
  align-items: center;
}

.listener-info {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.25);
  background: rgba(255, 255, 255, 0.08);
  color: var(--muted);
  font-size: 11px;
  font-weight: 700;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  padding: 0;
}

.listener-info:hover,
.listener-info:focus-visible {
  color: #fff;
  border-color: rgba(255, 255, 255, 0.45);
  background: rgba(255, 255, 255, 0.16);
  outline: none;
}

.transcript-modal {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.transcript-modal.open {
  display: flex;
}

.transcript-overlay {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.72);
}

.transcript-dialog {
  position: relative;
  width: min(92vw, 860px);
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  background: #1b1b1b;
  border: 1px solid #2b2b2b;
  border-radius: 18px;
  padding: 24px;
  box-shadow: 0 24px 60px rgba(0, 0, 0, 0.55);
  z-index: 1;
}

.transcript-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
}

.transcript-header h2 {
  margin: 0;
  font-size: 24px;
}

.transcript-close {
  appearance: none;
  border: 1px solid rgba(255, 255, 255, 0.2);
  background: rgba(255, 255, 255, 0.08);
  color: #fff;
  border-radius: 10px;
  width: 36px;
  height: 36px;
  font-size: 18px;
  cursor: pointer;
}

.transcript-close:focus-visible {
  outline: 2px solid rgba(255, 255, 255, 0.6);
  outline-offset: 2px;
}

.transcript-body {
  margin-top: 16px;
  padding-right: 6px;
  overflow-y: auto;
  flex: 1;
  min-height: 0;
}

.transcript-status {
  margin: 0;
  font-size: 15px;
  color: rgba(255, 255, 255, 0.8);
}

.transcript-cue {
  display: grid;
  grid-template-columns: 90px 1fr;
  gap: 12px;
  padding: 12px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

.transcript-cue:last-child {
  border-bottom: none;
}

.transcript-time {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.55);
  letter-spacing: 0.04em;
  text-transform: uppercase;
}

.transcript-text {
  font-size: 15px;
  line-height: 1.6;
  color: rgba(255, 255, 255, 0.92);
  word-break: break-word;
}

body.modal-open {
  overflow: hidden;
}

.listener-tooltip {
  position: absolute;
  top: 50%;
  right: 100%;
  z-index: 5;
  background: #1f1f1f;
  border: 1px solid rgba(255, 255, 255, 0.12);
  color: #e6e6e6;
  padding: 10px 12px;
  border-radius: 10px;
  font-size: 12px;
  line-height: 1.4;
  max-width: 240px;
  width: auto;
  opacity: 0;
  pointer-events: none;
  transform: translateY(-4px);
  transition: opacity 0.15s ease, transform 0.15s ease;
  box-shadow: 0 12px 28px rgba(0, 0, 0, 0.45);
}

.listener-tooltip.align-right {
  left: auto;
  right: 0;
}

.listener-info-wrap.open .listener-tooltip {
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0);
}

.rating-panel {
  margin-left: auto;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 6px;
  position: relative;
}

.rating-shell {
  background: rgba(14, 14, 14, 0.72);
  border: 1px solid rgba(255, 255, 255, 0.12);
  padding: 10px 12px;
  border-radius: 16px;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 8px;
  min-width: 220px;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
  transition: box-shadow 0.2s ease, border-color 0.2s ease;
  position: relative;
}

.rating-panel.is-voted .rating-shell {
  border-color: rgba(90, 200, 130, 0.35);
  background: rgba(18, 22, 19, 0.72);
  box-shadow: inset 0 0 0 1px rgba(90, 200, 130, 0.12);
}

.rating-shell:focus-within {
  border-color: rgba(245, 197, 107, 0.55);
  box-shadow: 0 0 0 2px rgba(245, 197, 107, 0.2), inset 0 0 0 1px rgba(255, 255, 255, 0.04);
}

.rating-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}

.rating-meta {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: rgba(255, 255, 255, 0.7);
  font-weight: 700;
  padding-right: 26px;
}

.rating-output {
  color: #f5c56b;
  font-weight: 800;
  font-size: 13px;
}

.rating-panel:not(.is-voted) .rating-output {
  opacity: 0.85;
}

.rating-panel.is-voted .rating-output {
  opacity: 1;
}

.rating-slider {
  width: 100%;
  accent-color: #f5c56b;
  height: 6px;
  cursor: pointer;
}

.rating-slider:focus-visible {
  outline: 2px solid rgba(245, 197, 107, 0.55);
  outline-offset: 4px;
  border-radius: 999px;
}

.rating-slider::-webkit-slider-runnable-track {
  height: 6px;
  border-radius: 999px;
  background: rgba(245, 197, 107, 0.28);
  box-shadow: inset 0 0 0 1px rgba(245, 197, 107, 0.4);
}

.rating-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #f5c56b;
  border: 2px solid #1b1b1b;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.35);
  margin-top: -6px;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.rating-slider::-moz-range-track {
  height: 6px;
  border-radius: 999px;
  background: rgba(245, 197, 107, 0.28);
  box-shadow: inset 0 0 0 1px rgba(245, 197, 107, 0.4);
}

.rating-slider::-moz-range-progress {
  height: 6px;
  border-radius: 999px;
  background: rgba(245, 197, 107, 0.75);
}

.rating-slider::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #f5c56b;
  border: 2px solid #1b1b1b;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.35);
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

@media (hover: hover) and (pointer: fine) {
  .rating-slider:hover::-webkit-slider-thumb,
  .rating-slider:active::-webkit-slider-thumb,
  .rating-slider:hover::-moz-range-thumb,
  .rating-slider:active::-moz-range-thumb {
    transform: scale(1.08);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
  }
}

.rating-tick {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 18px;
  height: 18px;
  border-radius: 999px;
  background: rgba(88, 190, 126, 0.95);
  color: #ffffff;
  font-size: 12px;
  font-weight: 900;
  display: grid;
  place-items: center;
  opacity: 0;
  transform: scale(0.9);
  transition: opacity 0.2s ease, transform 0.2s ease;
  pointer-events: none;
}

.rating-panel.is-voted .rating-tick {
  opacity: 1;
  transform: scale(1);
}

.rating-status {
  display: none;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: rgba(255, 255, 255, 0.82);
}

.rating-error {
  margin-top: 6px;
  font-size: 12px;
  color: #f7b0b0;
}


.bars { display: grid; gap: 10px; }

.bar-row {
  display: grid;
  grid-template-columns: 130px 1fr 46px;
  gap: 10px;
  align-items: center;
}

.bar-row label {
  color: var(--muted);
  font-size: 13px;
}

.track {
  height: 10px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid var(--line);
  overflow: hidden;
}

.fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent-rob), #ffb37a);
  width: 0%;
}

.bar-row strong {
  font-size: 13px;
  color: var(--muted);
  font-weight: 650;
  text-align: right;
}

.status {
  text-align: center;
  margin-top: 20px;
  color: #aaa;
  font-size: 14px;
}

.loading {
  color: #f5c56b;
  font-weight: 600;
  letter-spacing: 0.02em;
}

.film-awards {
  margin: 16px auto 0;
}

.film-awards__inner {
  max-width: 900px;
  margin: 0 auto;
  padding: 24px 16px 0;
  border-top: 1px solid var(--line);
}

.film-awards__toggle {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  padding: 0 0 16px;
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  text-align: left;
}

.film-awards__toggle:focus-visible {
  outline: 2px solid rgba(245, 197, 107, 0.6);
  outline-offset: 4px;
  border-radius: 10px;
}

.film-awards__heading {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.film-awards__title {
  margin: 0;
  font-size: 22px;
}

.film-awards__updated {
  font-size: 14px;
  color: var(--muted);
}

.film-awards__chevron {
  width: 22px;
  height: 22px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.25s ease;
}

.film-awards__toggle[aria-expanded="true"] .film-awards__chevron {
  transform: rotate(180deg);
}

.film-awards__content {
  overflow: hidden;
  max-height: 0;
  opacity: 0;
  transition: max-height 0.35s ease, opacity 0.2s ease;
}

.film-awards__content.is-open {
  opacity: 1;
}

.film-awards__list {
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding-bottom: 16px;
}

.film-award-row {
  background: var(--card);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 14px;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.film-award-meta {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.film-award-heading {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.film-award-title {
  margin: 0;
  font-size: 18px;
}

.film-award-description {
  margin: 0;
  color: var(--muted);
  font-size: 14px;
  line-height: 1.5;
}

.film-award-winner {
  margin: 0;
  font-size: 14px;
  color: rgba(255, 255, 255, 0.9);
}

#scroll-sentinel {
  height: 1px;
}


@media (max-width: 768px) {
  .films-list { padding: 0 16px; }
  .hero-layout {
    grid-template-columns: 1fr;
    padding-top: 0;
  }
  .film-poster-wrapper,
  .poster-wrap {
    max-width: none;
    width: 100%;
  }
  .poster {
    width: 100%;
    max-width: none;
    height: auto;
    display: block;
  }
  .hero-rank {
    top: calc(var(--poster-side-offset) - (var(--badge-height) * 0.2));
    left: var(--poster-side-offset);
    font-size: 13px;
    min-height: 26px;
    padding: 0 10px;
  }
  .controls {
    max-width: 900px;
    margin: 0 auto;
    padding: 0 16px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    align-items: stretch;
  }
  .mobile-controls {
    --control-icon-size: 18px;
    --control-icon-chevron-size: 12px;
    --control-icon-gap: 6px;
    --control-icon-right: 12px;
    --control-icon-area: 52px;
    --control-icon-muted: rgba(255, 255, 255, 0.55);
    --control-icon-active: #d46a2a;
  }
  .filters-row {
    max-width: none;
    padding: 0;
    margin: 0;
    overflow: visible;
  }
  .filter-row {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: stretch;
  }
  .control-row {
    display: flex;
    width: 100%;
    align-items: flex-end;
    gap: 8px;
  }
  .control-row .filter {
    flex: 1 1 auto;
    min-width: 0;
  }
  .mobile-filter-control {
    min-height: 44px;
    border-radius: 16px;
    padding: 0 14px;
    background: #2c2c2c;
  }
  .filter {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 6px;
    width: 100%;
  }
  .sort {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 6px;
    width: 100%;
    max-height: 0;
    opacity: 0;
    overflow: hidden;
    pointer-events: none;
    transition: max-height 0.23s ease, opacity 0.2s ease;
  }
  .controls.mobile-filters-open .sort {
    max-height: 120px;
    opacity: 1;
    pointer-events: auto;
    overflow: visible;
  }
  .filter label,
  .sort label,
  .film-search-wrap label {
    margin: 0;
    font-size: 13px;
    color: var(--muted);
  }
  .filter select,
  .sort select,
  .film-search-input {
    width: 100%;
    margin: 0;
    border: 2px solid #3f3f3f;
    font-weight: 600;
    height: 44px;
    min-height: 44px;
    border-radius: 16px;
    font-size: 16px;
    box-sizing: border-box;
  }
  .select-field {
    position: relative;
  }
  .select-icon {
    display: inline-flex;
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }
  .select-icon svg {
    display: block;
    width: 100%;
    height: 100%;
  }
  .select-icon--filter,
  .select-icon--sort {
    width: var(--control-icon-size);
    height: var(--control-icon-size);
    right: calc(var(--control-icon-right) + var(--control-icon-chevron-size) + var(--control-icon-gap));
    color: var(--control-icon-muted);
  }
  .select-field.has-nondefault .select-icon--filter,
  .select-field.has-nondefault .select-icon--sort {
    color: var(--control-icon-active);
  }
  .select-icon--chevron {
    width: var(--control-icon-chevron-size);
    height: var(--control-icon-chevron-size);
    right: var(--control-icon-right);
    color: rgba(255, 255, 255, 0.45);
  }
  .film-search-toggle {
    flex: 0 0 44px;
    width: 44px;
    height: 44px;
    min-height: 44px;
    border-radius: 14px;
    padding: 0;
    justify-content: center;
    font-size: 18px;
    line-height: 1;
  }
  .film-search-toggle-icon {
    width: 18px;
    height: 18px;
    color: currentColor;
  }
  .film-search-toggle {
    color: #b6b6b6;
    border: 1px solid rgba(255, 255, 255, 0.2);
    background: #2c2c2c;
  }
  .film-search-toggle.is-active,
  .film-search-toggle.has-filters {
    color: #f5c56b;
    background: rgba(245, 197, 107, 0.2);
    border: 1px solid rgba(245, 197, 107, 0.5);
    box-shadow: 0 0 10px rgba(245, 197, 107, 0.22);
  }
  .film-search-row {
    max-height: 0;
    opacity: 0;
    overflow: hidden;
    pointer-events: none;
    transition: max-height 0.23s ease, opacity 0.2s ease, padding 0.2s ease;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 16px;
    padding: 2px 12px;
  }
  .controls.mobile-filters-open .film-search-row {
    max-height: 220px;
    opacity: 1;
    pointer-events: auto;
    padding: 12px;
    margin-top: 8px;
    overflow: visible;
  }
  .film-search-wrap {
    display: flex;
    flex-direction: column;
    gap: 6px;
    width: 100%;
    overflow: visible;
  }
  .search-field {
    width: 100%;
    overflow: visible;
  }
  .film-search-input,
  .filter select,
  .sort select {
    -webkit-appearance: none;
    appearance: none;
    box-sizing: border-box;
    outline: none;
    -webkit-tap-highlight-color: transparent;
  }
  .film-search-input,
  .filter select,
  .sort select {
    padding-right: var(--control-icon-area);
  }
  .film-search-input:focus,
  .film-search-input:active,
  .sort select:focus,
  .sort select:active,
  .filter select:focus,
  .filter select:active {
    border-color: rgba(245, 197, 107, 0.5);
    outline: none;
    box-shadow: none;
  }
  .film-search-input:focus-visible,
  .sort select:focus-visible,
  .filter select:focus-visible {
    border-color: rgba(245, 197, 107, 0.45);
    outline: none;
    box-shadow: none;
  }
  .film-search-input:focus,
  .film-search-input:active,
  .film-search-input:focus-visible {
    border-color: #d46a2a;
  }
  .search-clear {
    position: absolute;
    top: 50%;
    right: 4px;
    transform: translateY(-50%);
    width: 44px;
    height: 44px;
    border: 0;
    padding: 0;
    border-radius: 999px;
    background: transparent;
    color: rgba(255, 255, 255, 0.55);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    line-height: 1;
    cursor: pointer;
  }
  .search-icon {
    display: inline-flex;
    position: absolute;
    top: 50%;
    right: var(--control-icon-right);
    width: var(--control-icon-size);
    height: var(--control-icon-size);
    transform: translateY(-50%);
    color: var(--control-icon-muted);
    pointer-events: none;
  }
  .search-icon svg {
    display: block;
    width: 100%;
    height: 100%;
  }
  .search-field.is-active .search-icon {
    opacity: 0;
  }
  .search-clear:hover,
  .search-clear:focus-visible,
  .search-clear:active {
    color: rgba(255, 255, 255, 0.9);
  }
  .search-clear[hidden] {
    display: none;
  }
  .film-search-suggestions {
    margin-top: 6px;
  }
  .rating-panel {
    margin-left: 0;
    width: 100%;
    align-items: stretch;
    order: 1;
  }
  .cta {
    flex-direction: column;
    align-items: stretch;
  }
  .cta-actions {
    order: 2;
    width: 100%;
    align-items: stretch;
  }
  .cta-actions .btn {
    width: 100%;
  }
  .rating-shell {
    width: 100%;
    min-width: 0;
  }
  .rating-meta {
    font-size: 12px;
  }
  .rating-output {
    font-size: 24px;
    line-height: 1;
  }
  .rosette-stack {
    top: calc(var(--poster-side-offset) - (var(--badge-height) * 0.2) + 2px);
    right: var(--poster-side-offset);
    flex-direction: column;
    align-items: flex-end;
    flex-wrap: nowrap;
  }
  .listener-score { flex-wrap: wrap; }
}

@media (min-width: 768px) {
  .cta-actions .button {
    padding-block: 0.65rem;
    padding-inline: 1.6rem;
    font-size: 16px;
  }

  .rating-shell {
    min-width: 280px;
  }

  .controls {
    max-width: 900px;
    margin: 0 auto;
    padding: 0 16px;
  }

  .filters-toolbar {
    display: grid;
    grid-template-columns: minmax(160px, 220px) minmax(160px, 220px) minmax(280px, 1fr);
    grid-template-rows: auto auto auto;
    column-gap: 14px;
    row-gap: 6px;
    align-items: end;
    width: 100%;
  }

  .filters-row {
    max-width: none;
    margin: 0;
    padding: 0;
  }

  .filter-row,
  .control-row,
  .filters-toolbar__group {
    display: contents;
  }

  .filter,
  .sort,
  .film-search-row,
  .film-search-wrap {
    display: contents;
  }
  .select-field {
    display: contents;
  }

  .filter > label,
  .sort > label,
  .film-search-wrap > label {
    margin: 0;
    font-size: 13px;
    line-height: 1.2;
    min-height: 16px;
    align-self: end;
  }

  .filter > label {
    grid-column: 1;
    grid-row: 1;
  }

  .sort > label {
    grid-column: 2;
    grid-row: 1;
  }

  .film-search-wrap > label {
    grid-column: 3;
    grid-row: 1;
  }

  .filter > select,
  .filter > .select-field > select {
    grid-column: 1;
    grid-row: 2;
  }

  .sort > select,
  .sort > .select-field > select {
    grid-column: 2;
    grid-row: 2;
  }

  .search-field {
    grid-column: 3;
    grid-row: 2;
    min-width: 0;
    align-self: end;
  }

  .film-search-suggestions {
    grid-column: 3;
    grid-row: 3;
    margin-top: 6px;
    min-height: 1em;
  }

  .film-search-row,
  .film-search-row.is-open {
    max-height: none;
    opacity: 1;
    overflow: visible;
    pointer-events: auto;
  }

  .filter select,
  .sort select,
  .film-search-input {
    height: 44px;
    min-height: 44px;
    box-sizing: border-box;
  }

  .filter select,
  .sort select,
  .film-search-input {
    border-width: 2px;
  }

  .filter select:focus,
  .filter select:focus-visible,
  .sort select:focus,
  .sort select:focus-visible,
  .film-search-input:focus,
  .film-search-input:focus-visible,
  .film-search-input:active {
    outline: none;
    box-shadow: none;
    border-color: #d46a2a;
  }

  .film-search-input {
    width: 100%;
    min-width: 0;
  }

  .film-search-toggle {
    display: none;
  }

  .film-search-toggle-icon--filter {
    display: none;
  }

  .film-search-toggle-icon--search {
    display: inline;
  }

  .film-search-toggle.is-active {
    color: #d46a2a;
    border-color: rgba(212, 106, 42, 0.55);
    background: rgba(212, 106, 42, 0.18);
    box-shadow: 0 0 10px rgba(212, 106, 42, 0.2);
  }

  .films-list {
    gap: 26px;
  }

  .rosette-stack {
    top: calc(var(--poster-side-offset) - var(--badge-height) - var(--badge-above-poster-gap) + 2px);
    right: var(--poster-side-offset);
    gap: 8px;
    flex-direction: row;
    align-items: center;
    flex-wrap: nowrap;
  }

  .rosette {
    font-size: 12px;
    padding: 6px 12px;
  }
}

@media (min-width: 1024px) {
  .cta-actions .button {
    padding-block: 0.75rem;
    padding-inline: 1.85rem;
    font-size: 17px;
  }

  .rating-shell {
    min-width: 320px;
  }
}

@media (max-width: 760px) {
  .detail-row,
  .rob-details .detail-row {
    grid-template-columns: 1fr;
  }

  .score-row {
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 8px;
  }

  .score-card {
    border-radius: 14px;
    padding: 10px;
  }

  .score-label {
    font-size: 11px;
    letter-spacing: 0.06em;
  }

  .score-value {
    font-size: 24px;
  }
}

@media (max-width: 640px) {
  .mobile-controls .control-row .control { min-width: 0; }
  .mobile-controls .film-search-toggle {
    flex: 0 0 44px;
    width: 44px;
    height: 44px;
    min-height: 44px;
  }
  .mobile-controls .filter select,
  .mobile-controls .sort select,
  .mobile-controls .film-search-input {
    width: 100%;
    height: 44px;
    min-height: 44px;
    border-radius: 999px;
    padding: 0 14px;
    padding-right: var(--control-icon-area);
  }
  .mobile-controls .film-search-row {
    background: transparent;
    border: 0;
    border-radius: 0;
    padding: 0;
  }
  .mobile-controls.mobile-filters-open .film-search-row {
    padding: 0;
  }
  .mobile-controls .film-search-wrap {
    background: transparent;
    border: 0;
    padding: 0;
    border-radius: 0;
  }
  .mobile-controls .film-search-input,
  .mobile-controls .sort select,
  .mobile-controls .filter select {
    -webkit-appearance: none;
    appearance: none;
  }
  .mobile-controls .film-search-input:focus-visible,
  .mobile-controls .sort select:focus-visible,
  .mobile-controls .filter select:focus-visible {
    border-color: rgba(245, 197, 107, 0.45);
    outline: none;
    box-shadow: none;
  }
  .mobile-controls .film-search-input:focus,
  .mobile-controls .film-search-input:active,
  .mobile-controls .film-search-input:focus-visible {
    border-color: #d46a2a;
  }
}

@media (max-width: 520px) {
  .bar-row { grid-template-columns: 110px 1fr 40px; }
}

@media (max-width: 400px) {
  .rating-shell {
    padding: 10px;
  }
}
</style>
</head>

<body>

<div id="site-header"></div>

<template id="header-extras-template">
  <div class="controls mobile-controls">
    <div class="filters-toolbar">
    <div class="filters-row filter-row">
      <div class="control-row">
      <div class="filter control filters-toolbar__group">
        <label for="filmFilter">Show films</label>
        <div class="select-field select-field--filter">
          <select id="filmFilter" class="mobile-filter-control" data-default-value="rob">
            <option value="all">All Films</option>
            <option value="real">Real Films</option>
            <option value="rob" selected>Robâ€™s Films</option>
          </select>
          <span class="select-icon select-icon--filter" aria-hidden="true">
            <svg viewBox="0 0 24 24" focusable="false" aria-hidden="true">
              <path fill="currentColor" d="M3 5.75A.75.75 0 0 1 3.75 5h16.5a.75.75 0 0 1 .56 1.25l-6.31 7.1v4.56a.75.75 0 0 1-.35.63l-3 1.91A.75.75 0 0 1 10 19.8v-6.45L3.19 6.25A.75.75 0 0 1 3 5.75Z"/>
            </svg>
          </span>
          <span class="select-icon select-icon--chevron" aria-hidden="true">
            <svg viewBox="0 0 12 8" focusable="false" aria-hidden="true">
              <path fill="currentColor" d="M1.41.59 6 5.17 10.59.59 12 2l-6 6-6-6z"/>
            </svg>
          </span>
        </div>
      </div>

      <button id="filmSearchToggle" class="film-search-toggle mobile-filter-control" type="button" aria-expanded="false" aria-controls="filmSearchRow" aria-label="Toggle search">
        <svg class="film-search-toggle-icon film-search-toggle-icon--filter" aria-hidden="true" viewBox="0 0 24 24" focusable="false">
          <path fill="currentColor" d="M3 5.75A.75.75 0 0 1 3.75 5h16.5a.75.75 0 0 1 .56 1.25l-6.31 7.1v4.56a.75.75 0 0 1-.35.63l-3 1.91A.75.75 0 0 1 10 19.8v-6.45L3.19 6.25A.75.75 0 0 1 3 5.75Z"/>
        </svg>
        <svg class="film-search-toggle-icon film-search-toggle-icon--search" aria-hidden="true" viewBox="0 0 24 24" focusable="false">
          <path fill="currentColor" d="M11 4a7 7 0 1 0 4.95 11.95l3.55 3.55a1 1 0 0 0 1.42-1.42l-3.55-3.55A7 7 0 0 0 11 4Zm0 2a5 5 0 1 1 0 10 5 5 0 0 1 0-10Z"/>
        </svg>
        <span class="film-search-toggle-text">Search</span>
        <span class="film-search-toggle-label">Search films</span>
      </button>
      </div>

      <div class="sort control filters-toolbar__group">
        <label for="sortSelect">Sort by</label>
        <div class="select-field select-field--sort">
          <select id="sortSelect" class="mobile-filter-control" data-default-value="rating-desc">
            <option value="rating-desc">Rating (High to Low)</option>
            <option value="rating-asc">Rating (Low to High)</option>
            <option value="podcast-desc">Podcast Date (New to Old)</option>
            <option value="podcast-asc">Podcast Date (Old to New)</option>
            <option value="listener-desc" data-listener-option>Listener Rating (High to Low)</option>
            <option value="listener-asc" data-listener-option>Listener Rating (Low to High)</option>
          </select>
          <span class="select-icon select-icon--sort" aria-hidden="true">
            <svg viewBox="0 0 24 24" focusable="false" aria-hidden="true">
              <path fill="currentColor" d="M7 4a1 1 0 0 1 1 1v11.59l2.3-2.3a1 1 0 1 1 1.4 1.42l-4.01 4.01a1 1 0 0 1-1.4 0l-4-4a1 1 0 1 1 1.41-1.42L6 16.59V5a1 1 0 0 1 1-1Zm10 0a1 1 0 0 1 .71.29l4 4a1 1 0 0 1-1.42 1.42L18 7.41V19a1 1 0 1 1-2 0V7.41l-2.3 2.3a1 1 0 1 1-1.4-1.42l4-4A1 1 0 0 1 17 4Z"/>
            </svg>
          </span>
          <span class="select-icon select-icon--chevron" aria-hidden="true">
            <svg viewBox="0 0 12 8" focusable="false" aria-hidden="true">
              <path fill="currentColor" d="M1.41.59 6 5.17 10.59.59 12 2l-6 6-6-6z"/>
            </svg>
          </span>
        </div>
      </div>
    </div>

    <div id="filmSearchRow" class="filters-row film-search-row filters-toolbar__group filters-toolbar__group--search" aria-hidden="true">
      <div class="film-search-wrap control">
        <label id="filmSearchLabel" for="filmSearchInput">Search</label>
        <div class="search-field">
          <input id="filmSearchInput" class="film-search-input mobile-filter-control" type="search" placeholder="Search films by title or cast" autocomplete="off" />
          <span class="search-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" focusable="false" aria-hidden="true">
              <path fill="currentColor" d="M11 4a7 7 0 1 0 4.95 11.95l3.55 3.55a1 1 0 0 0 1.42-1.42l-3.55-3.55A7 7 0 0 0 11 4Zm0 2a5 5 0 1 1 0 10 5 5 0 0 1 0-10Z"/>
            </svg>
          </span>
          <button type="button" id="filmSearchClear" class="search-clear" aria-label="Clear search" hidden>Ã—</button>
        </div>
        <div id="filmSearchSuggestions" class="film-search-suggestions" aria-live="polite"></div>
      </div>
    </div>
    </div>
  </div>

</template>

<div id="films" class="films-list"></div>
<div id="status" class="status"></div>
<section id="film-awards" class="film-awards" aria-labelledby="film-awards-title" hidden></section>
<div id="loading" class="status loading" aria-live="polite" hidden></div>
<div id="scroll-sentinel" aria-hidden="true"></div>

<div class="transcript-modal" id="transcript-modal" aria-hidden="true">
  <div class="transcript-overlay" data-transcript-close></div>
  <div class="transcript-dialog" role="dialog" aria-modal="true" aria-labelledby="transcript-title">
    <div class="transcript-header">
      <h2 id="transcript-title">Transcript</h2>
      <button class="transcript-close" type="button" data-transcript-close aria-label="Close transcript">âœ•</button>
    </div>
    <div class="transcript-body" id="transcript-body" tabindex="0"></div>
  </div>
</div>

<div id="site-footer"></div>
<script src="/assets/js/shared.js"></script>
<script>
  const headerContainer = document.getElementById("site-header");
  const headerExtrasTemplate = document.getElementById("header-extras-template");
  fetch("/assets/header.html")
    .then((response) => response.text())
    .then((html) => {
      headerContainer.innerHTML = html;
      const activePath = window.location.pathname === "/" ? "/index.html" : window.location.pathname;
      const navLinks = headerContainer.querySelectorAll(".nav-links a");
      navLinks.forEach((link) => {
        if (link.getAttribute("href") === activePath) {
          link.classList.add("active");
        }
      });
      if (headerExtrasTemplate) {
        const extrasTarget = headerContainer.querySelector("#header-extras");
        if (extrasTarget) {
          extrasTarget.appendChild(headerExtrasTemplate.content.cloneNode(true));
          document.dispatchEvent(new CustomEvent("header:ready"));
        }
      }
    })
    .catch((error) => {
      console.error("Failed to load header:", error);
    });

  const footerContainer = document.getElementById("site-footer");
  fetch("/assets/footer.html")
    .then((response) => response.text())
    .then((html) => {
      footerContainer.innerHTML = html;
    })
    .catch((error) => {
      console.error("Failed to load footer:", error);
    });
</script>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script type="module">
import { buildPodcastEpisodeSchemaFromFilm, injectJsonLd } from "/assets/js/seo.js";
import { loadFilmsData } from "./assets/js/films-data.js";

const BASE_URL = "https://nocontextcinemaclub.com/";
let allFilms = [];
let currentFilter = "rob";
let currentSort = "rating-desc";
let filmSearchQuery = "";
let lastScoreFetchKey = "";
const listenerScores = {};
const audienceScores = {};
const RATING_STORAGE_KEY = "nccc_film_ratings";
const SUPABASE_URL = "https://johklrouorflqfmzpiaw.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpvaGtscm91b3JmbHFmbXpwaWF3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk5NzgzNDQsImV4cCI6MjA4NTU1NDM0NH0.28kgIYh_BW-Ok2EHtxvm0NZM4e_0k2HzSFN0bkj9NPw";
const supabaseClient = window.supabase?.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
const localRatings = loadLocalRatings();
let openTooltip = null;

const INSIGHT_MIN_VOTES = 1;
const INSIGHT_GAP_MIN = 1;
const INSIGHT_DIV_MIN = 1;
const AWARDS_CONTENT_ID = "film-awards-content";
let awardsExpanded = false;
let awardsLastUpdatedAt = null;

// Award calculation approach: central config with winner selectors for the live Rob films dataset.
const AWARDS = [
  {
    key: "kev-pick",
    label: "Kevâ€™s Pick",
    emoji: "ðŸ†",
    rosetteClass: "rosette--kev-pick",
    description: "Awarded to the film that Kev loves the most.",
    getWinners: (films, aggregates) => getTopAwardWinners(films, (film) => {
      const kevRating = getKevRating10(film, aggregates);
      return Number.isFinite(kevRating) ? kevRating : null;
    })
  },
  {
    key: "listener-pick",
    label: "Listener Pick",
    emoji: "â¤ï¸",
    rosetteClass: "rosette--listener-pick",
    description: "Awarded to the film that listeners can't live without.",
    getWinners: (films, aggregates) => getTopAwardWinners(films, (film) => {
      const listenerAvg = getListenerAverage10(film, aggregates);
      const listenerCount = getListenerCount(film, aggregates);
      if (!Number.isFinite(listenerAvg) || listenerCount <= 0) return null;
      return listenerAvg;
    })
  },
  {
    key: "new",
    label: "New",
    emoji: "ðŸ†•",
    rosetteClass: "rosette--new",
    description: "The most recently podcasted film. Not really an award but nice to know.",
    singularLabel: "Most recent",
    pluralLabel: "Most recent",
    emptyWinnersText: "Most recent: â€”",
    getWinners: (films) => getTopAwardWinners(films, (film) => {
      const newest = getNewestFilmTimestamp(film);
      return Number.isFinite(newest) ? newest : null;
    })
  },
  {
    key: "most-underrated",
    label: "Most Underrated",
    emoji: "â¬†ï¸",
    rosetteClass: "rosette--most-underrated",
    description: "Awarded to the film which has the largest positive difference from the listener score to Kev's score",
    getWinners: (films, aggregates) => getBestSingleWinner(
      films,
      (film) => {
        const listenerAvg = getListenerAverage10(film, aggregates);
        const kevRating = getKevRating10(film, aggregates);
        const listenerCount = getListenerCount(film, aggregates);
        if (listenerCount < INSIGHT_MIN_VOTES || !Number.isFinite(listenerAvg) || !Number.isFinite(kevRating)) return null;
        const gap = listenerAvg - kevRating;
        return gap >= INSIGHT_GAP_MIN / 10 ? gap : null;
      },
      (film) => getListenerCount(film, aggregates)
    )
  },
  {
    key: "most-overrated",
    label: "Most Overrated",
    emoji: "â¬‡ï¸",
    rosetteClass: "rosette--most-overrated",
    description: "Awarded to the film which has the largest negative difference from the listener score to Kev's score",
    getWinners: (films, aggregates) => getBestSingleWinner(
      films,
      (film) => {
        const listenerAvg = getListenerAverage10(film, aggregates);
        const kevRating = getKevRating10(film, aggregates);
        const listenerCount = getListenerCount(film, aggregates);
        if (listenerCount < INSIGHT_MIN_VOTES || !Number.isFinite(listenerAvg) || !Number.isFinite(kevRating)) return null;
        const gap = kevRating - listenerAvg;
        return gap >= INSIGHT_GAP_MIN / 10 ? gap : null;
      },
      (film) => getListenerCount(film, aggregates)
    )
  },
  {
    key: "most-divisive",
    label: "Most Divisive",
    emoji: "âš¡",
    rosetteClass: "rosette--most-divisive",
    description: "Awarded to the film with the biggest rating varience. Some listeners love it, some (probably most) hate it",
    getWinners: (films, aggregates) => getBestSingleWinnerWithTiebreak(
      films,
      (film) => {
        const listenerCount = getListenerCount(film, aggregates);
        if (listenerCount < INSIGHT_MIN_VOTES) return null;
        const metric = getDivisiveAwardMetric(film, aggregates);
        return Number.isFinite(metric) && metric >= INSIGHT_DIV_MIN ? metric : null;
      },
      (film) => getListenerCount(film, aggregates),
      (film) => {
        const listenerAvg10 = getListenerAverage10(film, aggregates);
        const kevAvg10 = getKevRating10(film, aggregates);
        const gapVsKev = Number.isFinite(listenerAvg10) && Number.isFinite(kevAvg10)
          ? Math.abs(listenerAvg10 - kevAvg10)
          : -1;
        return {
          gapVsKev,
          title: String(film.title || "")
        };
      }
    )
  },
  {
    key: "lost-plot",
    label: "Lost the Plot",
    emoji: "ðŸŒ€",
    rosetteClass: "rosette--lost-plot",
    description: "Furthest from the real film.",
    shouldDisplay: (films, aggregates) => films.some((film) => (
      Number.isFinite(getRottenTomatoesScore10(film, aggregates))
    )),
    getWinners: (films, aggregates) => getBestSingleWinner(
      films,
      (film) => {
        const kevRating = getKevRating10(film, aggregates);
        const listenerAvg = getListenerAverage10(film, aggregates);
        const rottenScore = getRottenTomatoesScore10(film, aggregates);
        if (!Number.isFinite(kevRating) || !Number.isFinite(listenerAvg) || !Number.isFinite(rottenScore)) return null;
        return (Math.abs(kevRating - rottenScore) + Math.abs(listenerAvg - rottenScore)) / 2;
      },
      (film) => getListenerCount(film, aggregates)
    )
  },
  {
    key: "fixed-it",
    label: "Fixed It",
    emoji: "âœ¨",
    rosetteClass: "rosette--fixed-it",
    description: "Kevâ€™s score is higher than Rotten Tomatoes for the real film with the same name.",
    emptyWinnersText: "Winners: â€”",
    getWinners: (films, aggregates) => films.filter((film) => {
      const kevRating = getKevRating10(film, aggregates);
      const rottenScore = getRottenTomatoesScore10(film, aggregates);
      if (!Number.isFinite(kevRating) || !Number.isFinite(rottenScore)) return false;
      return kevRating > rottenScore;
    })
  },
  {
    key: "consensus-achieved",
    label: "Consensus Achieved",
    emoji: "ðŸ¤",
    rosetteClass: "rosette--consensus",
    description: "Kev and listeners agreed the most.",
    getWinners: (films, aggregates) => getBestSingleWinnerLowest(
      films,
      (film) => {
        const kevRating = getKevRating10(film, aggregates);
        const listenerAvg = getListenerAverage10(film, aggregates);
        if (!Number.isFinite(kevRating) || !Number.isFinite(listenerAvg)) return null;
        return Math.abs(kevRating - listenerAvg);
      },
      (film) => getListenerCount(film, aggregates)
    )
  }
];

function assertAwardsConfig() {
  const keys = AWARDS.map((award) => award.key);
  const uniqueKeys = new Set(keys);
  console.assert(uniqueKeys.size === keys.length, "Award keys must be unique.");
}

assertAwardsConfig();

const PAGE_SIZE = 10;
let visibleCount = PAGE_SIZE;
let loadingMore = false;
let currentTotal = 0;
const container = document.getElementById("films");
const statusEl = document.getElementById("status");
const loadingEl = document.getElementById("loading");
const sentinelEl = document.getElementById("scroll-sentinel");
const awardsSection = document.getElementById("film-awards");
const transcriptModal = document.getElementById("transcript-modal");
const transcriptDialog = transcriptModal?.querySelector(".transcript-dialog");
const transcriptBody = document.getElementById("transcript-body");
const transcriptTitle = document.getElementById("transcript-title");
let transcriptTrigger = null;

function parseLocalDate(d) {
  if (!d) return null;
  const [year, month, day] = d.split("-").map(Number);
  if (!year || !month || !day) return null;
  const dt = new Date(year, month - 1, day);
  return isNaN(dt.getTime()) ? null : dt;
}

function safeDate(d) {
  return parseLocalDate(d);
}

function formatUkDate(d) {
  const dt = parseLocalDate(d);
  return dt ? dt.toLocaleDateString("en-GB").replaceAll("/", "-") : d;
}

function parseTimestamp(value) {
  if (!value) return null;
  if (value instanceof Date) return Number.isNaN(value.getTime()) ? null : value;
  if (typeof value === "number") {
    const numericDate = new Date(value);
    return Number.isNaN(numericDate.getTime()) ? null : numericDate;
  }
  if (typeof value === "string") {
    const localDate = parseLocalDate(value);
    if (localDate) return localDate;
    const parsed = new Date(value);
    return Number.isNaN(parsed.getTime()) ? null : parsed;
  }
  return null;
}

function isSameCalendarDay(a, b) {
  return a.getFullYear() === b.getFullYear()
    && a.getMonth() === b.getMonth()
    && a.getDate() === b.getDate();
}

function getMonthDifference(start, end) {
  let months = (end.getFullYear() - start.getFullYear()) * 12
    + (end.getMonth() - start.getMonth());
  if (end.getDate() < start.getDate()) {
    months -= 1;
  }
  return Math.max(months, 0);
}

function timeSinceLabel(dateValue) {
  const parsed = parseTimestamp(dateValue);
  if (!parsed) return "â€”";
  const now = new Date();
  if (isSameCalendarDay(parsed, now)) return "today";
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const dateStart = new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
  const diffMs = todayStart.getTime() - dateStart.getTime();
  if (!Number.isFinite(diffMs)) return "â€”";
  const daysAgo = Math.max(0, Math.floor(diffMs / 86400000));

  if (daysAgo >= 1 && daysAgo <= 6) {
    return daysAgo === 1 ? "1 day ago" : `${daysAgo} days ago`;
  }

  if (daysAgo >= 7 && daysAgo <= 27) {
    const weeksAgo = Math.floor(daysAgo / 7);
    return weeksAgo === 1 ? "1 week ago" : `${weeksAgo} weeks ago`;
  }

  let monthsAgo = getMonthDifference(parsed, now);
  if (monthsAgo < 1) monthsAgo = 1;

  if (monthsAgo >= 1 && monthsAgo <= 11) {
    return monthsAgo === 1 ? "1 month ago" : `${monthsAgo} months ago`;
  }

  const years = Math.floor(monthsAgo / 12);
  const remMonths = monthsAgo % 12;
  if (remMonths === 0) {
    return years === 1 ? "1 year ago" : `${years} years ago`;
  }
  const yearPart = years === 1 ? "1 year" : `${years} years`;
  const monthPart = remMonths === 1 ? "1 month" : `${remMonths} months`;
  return `${yearPart} ${monthPart} ago`;
}

function calcRobScore(film) {
  const total = film.coherence + film.entertainment + film.originality;
  film.totalScore = total;
  film.score = (total / 30) * 100;
  film.kevScore = film.kevScore ?? film.score;
  film.scoreLabel = "ðŸŽ™ï¸ Kevâ€™s Score";
}

function escapeHtml(value) {
  return value
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll("\"", "&quot;")
    .replaceAll("'", "&#39;");
}

function formatTranscriptText(text) {
  const lines = text.split("\n");
  return lines
    .map((line) => {
      const trimmed = line.trim();
      const voiceMatch = trimmed.match(/^<v\s+([^>]+)>\s*(.*)$/i);
      if (voiceMatch) {
        const speaker = escapeHtml(voiceMatch[1].trim());
        const remainder = escapeHtml(voiceMatch[2].trim());
        return remainder
          ? `<strong>${speaker}:</strong> ${remainder}`
          : `<strong>${speaker}:</strong>`;
      }
      const match = trimmed.match(/^([A-Z][A-Z0-9 ]+):\s*(.*)$/);
      if (!match) return escapeHtml(line);
      const speaker = escapeHtml(match[1]);
      const remainder = escapeHtml(match[2]);
      return `<strong>${speaker}:</strong> ${remainder}`;
    })
    .join("<br>");
}

function formatTranscriptTime(time) {
  if (!time) return "";
  const base = time.split(".")[0];
  const parts = base.split(":");
  if (parts.length === 2) {
    return `00:${parts[0].padStart(2, "0")}:${parts[1].padStart(2, "0")}`;
  }
  if (parts.length === 3) {
    return `${parts[0].padStart(2, "0")}:${parts[1].padStart(2, "0")}:${parts[2].padStart(2, "0")}`;
  }
  return base;
}

function parseTranscriptTxt(text) {
  const cleaned = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  const lines = cleaned.split("\n");
  const cues = [];
  const headerPattern = /^([^:]+):\s*(\d{1,2}:\d{2}(?::\d{2})?)/;
  let index = 0;

  while (index < lines.length) {
    const line = lines[index].trim();
    const match = line.match(headerPattern);

    if (!match) {
      index += 1;
      continue;
    }

    const speaker = match[1].trim();
    const startTime = match[2].trim();
    index += 1;

    const textLines = [];
    while (index < lines.length && !lines[index].trim().match(headerPattern)) {
      const textLine = lines[index].trim();
      if (textLine) textLines.push(textLine);
      index += 1;
    }

    const text = textLines.join("\n").trim();
    if (text || speaker) {
      cues.push({
        startTime,
        text: speaker ? `${speaker}: ${text}`.trim() : text,
      });
    }
  }

  return cues;
}

function setTranscriptStatus(message) {
  if (!transcriptBody) return;
  transcriptBody.innerHTML = `<p class="transcript-status">${message}</p>`;
}

function renderTranscript(cues) {
  if (!transcriptBody) return;
  transcriptBody.innerHTML = "";
  cues.forEach((cue) => {
    const cueEl = document.createElement("div");
    cueEl.className = "transcript-cue";
    cueEl.innerHTML = `
      <div class="transcript-time">${escapeHtml(formatTranscriptTime(cue.startTime))}</div>
      <div class="transcript-text">${formatTranscriptText(cue.text)}</div>
    `;
    transcriptBody.appendChild(cueEl);
  });
}

function getFocusableElements() {
  if (!transcriptDialog) return [];
  return Array.from(
    transcriptDialog.querySelectorAll(
      "button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])"
    )
  ).filter((el) => !el.hasAttribute("disabled"));
}

let transcriptRequestId = 0;

async function openTranscriptModal({ title, txtUrl, trigger }) {
  if (!transcriptModal || !transcriptDialog || !transcriptBody) return;
  transcriptTrigger = trigger;
  if (transcriptTitle) {
    transcriptTitle.textContent = title ? `Transcript: ${title}` : "Transcript";
  }
  transcriptModal.classList.add("open");
  transcriptModal.setAttribute("aria-hidden", "false");
  document.body.classList.add("modal-open");
  setTranscriptStatus("Loading transcript...");
  transcriptBody.scrollTop = 0;

  const closeButton = transcriptModal.querySelector(".transcript-close");
  if (closeButton) closeButton.focus();

  const requestId = (transcriptRequestId += 1);

  try {
    const response = await fetch(txtUrl);
    if (!response.ok) throw new Error(`Failed to load transcript (${response.status}).`);
    const text = await response.text();
    if (requestId !== transcriptRequestId) return;
    const cues = parseTranscriptTxt(text);
    if (!cues.length) {
      setTranscriptStatus("Transcript is not available yet.");
      return;
    }
    renderTranscript(cues);
  } catch (error) {
    console.error("Transcript fetch failed:", error);
    if (requestId !== transcriptRequestId) return;
    setTranscriptStatus("Sorry, we couldnâ€™t load that transcript right now.");
  }
}

function closeTranscriptModal() {
  if (!transcriptModal) return;
  transcriptModal.classList.remove("open");
  transcriptModal.setAttribute("aria-hidden", "true");
  document.body.classList.remove("modal-open");
  transcriptRequestId += 1;
  if (transcriptTrigger) {
    transcriptTrigger.focus();
    transcriptTrigger = null;
  }
}

function handleTranscriptKeydown(event) {
  if (!transcriptModal?.classList.contains("open")) return;
  if (event.key === "Escape") {
    event.preventDefault();
    closeTranscriptModal();
    return;
  }
  if (event.key !== "Tab") return;
  const focusable = getFocusableElements();
  if (!focusable.length) return;
  const first = focusable[0];
  const last = focusable[focusable.length - 1];
  if (event.shiftKey && document.activeElement === first) {
    event.preventDefault();
    last.focus();
  } else if (!event.shiftKey && document.activeElement === last) {
    event.preventDefault();
    first.focus();
  }
}

function loadLocalRatings() {
  try {
    const stored = localStorage.getItem(RATING_STORAGE_KEY);
    return stored ? JSON.parse(stored) : {};
  } catch (error) {
    console.warn("Failed to load local ratings.", error);
    return {};
  }
}

function saveLocalRatings() {
  localStorage.setItem(RATING_STORAGE_KEY, JSON.stringify(localRatings));
}

function formatListenerRating(score) {
  const safeScore = Number(score);
  if (!Number.isFinite(safeScore) || safeScore <= 0) return "â€”";
  const rounded = Math.round(safeScore * 10) / 10;
  const display = Number.isInteger(rounded) ? `${rounded}` : rounded.toFixed(1);
  return `${display}/10`;
}

function formatAudienceScore(value) {
  const score = getPercentRaw(value);
  if (score === null) return null;
  return roundPercent(score);
}

function formatPercentLabel(value) {
  const rounded = roundPercent(value);
  return rounded === null ? "â€”" : `${rounded}%`;
}

function formatAwardsUpdatedLabel(timestamp) {
  const date = parseTimestamp(timestamp);
  if (!date) return "Last updated: â€”";
  const diffMs = Date.now() - date.getTime();
  const diffMinutes = Math.floor(diffMs / (60 * 1000));
  if (diffMinutes < 1) return "Check out our Film Awards, awarded to Rob's films and voted on by you and Kev. Last updated: just now";
  if (diffMinutes < 60) return `Check out our Film Awards, awarded to Rob's films and voted on by you and Kev. Last updated: ${diffMinutes} mins ago`;
  const formatted = date.toLocaleDateString("en-GB", { day: "numeric", month: "short", year: "numeric" });
  return `Check out our Film Awards, awarded to Rob's films and voted on by you and Kev. Last updated: ${formatted}`;
}

function setRatingError(panel, message) {
  if (!panel) return;
  const errorEl = panel.querySelector(".rating-error");
  if (!errorEl) return;
  errorEl.textContent = message;
  errorEl.hidden = !message;
}

function resetPagination() {
  visibleCount = PAGE_SIZE;
}

function updateLoadingState(isLoading) {
  loadingMore = isLoading;
  if (!loadingEl) return;
  loadingEl.textContent = isLoading ? "Loading More..." : "";
  loadingEl.hidden = !isLoading;
}

function updateStatus(visible, total) {
  statusEl.textContent = `Showing ${visible} of ${total} films.`;
}

function updateSentinelVisibility() {
  if (!sentinelEl) return;
  sentinelEl.hidden = visibleCount >= currentTotal;
}

function updatePodcastEpisodeSchema() {
  const activeFilms = allFilms.filter(film => film.active);
  const episodes = activeFilms
    .map(film => buildPodcastEpisodeSchemaFromFilm(film, { baseUrl: BASE_URL }))
    .filter(Boolean);
  if (episodes.length) {
    injectJsonLd("podcast-episode-schema", episodes);
  }
}

function getAudienceSortValues(film) {
  const audienceData = audienceScores[film.id];
  const weighted = Number(audienceData?.weighted_percent);
  const listenerCount = Number(audienceData?.listener_count);
  return {
    weighted: Number.isFinite(weighted) ? weighted : -1,
    listenerCount: Number.isFinite(listenerCount) ? listenerCount : 0
  };
}

function isAudienceDrivenSort(sortValue = currentSort) {
  return sortValue === "listener-asc"
    || sortValue === "listener-desc"
    || sortValue === "audience"
    || sortValue === "votes";
}

function compareAudience(a, b) {
  const aValues = getAudienceSortValues(a);
  const bValues = getAudienceSortValues(b);
  if (aValues.weighted !== bValues.weighted) {
    return bValues.weighted - aValues.weighted;
  }
  if (aValues.listenerCount !== bValues.listenerCount) {
    return bValues.listenerCount - aValues.listenerCount;
  }
  return 0;
}

function stableSortFilms(films, comparator) {
  return films
    .map((film) => ({
      film,
      originalIndex: Number.isInteger(film.originalIndex) ? film.originalIndex : 0
    }))
    .sort((a, b) => {
      const result = comparator(a.film, b.film);
      if (result !== 0) return result;
      return a.originalIndex - b.originalIndex;
    })
    .map(({ film }) => film);
}

function parseListenerRatingValue(value) {
  if (value === null || value === undefined || value === "") return null;
  const cleanedValue = typeof value === "string" ? value.replace(/%/g, "").trim() : value;
  const score = Number(cleanedValue);
  if (!Number.isFinite(score)) return null;
  return score;
}

function getPercentRaw(value) {
  const score = Number(value);
  return Number.isFinite(score) ? score : null;
}

function normaliseScoreToPercent(value) {
  const score = Number(value);
  if (!Number.isFinite(score)) return null;
  if (score >= 0 && score <= 10) return score * 10;
  if (score >= 0 && score <= 100) return score;
  return null;
}

function getInsightEligibleData(film) {
  const kevScoreNorm = normaliseScoreToPercent(film.kevScore ?? film.score);
  const listenerScoreNorm = normaliseScoreToPercent(
    audienceScores[film.id]?.weighted_percent
      ?? film.listenerScore
      ?? film.listenerRating
      ?? film.listenerPercent
      ?? film.listener_score
  );
  const listenerVotesRaw = audienceScores[film.id]?.listener_count
    ?? film.listenerVotes
    ?? (Array.isArray(film.listenerRatings) ? film.listenerRatings.length : null);
  const listenerVotes = Number(listenerVotesRaw);
  const validVotes = Number.isFinite(listenerVotes) ? listenerVotes : 0;

  return {
    kevScoreNorm,
    listenerScoreNorm,
    listenerVotes: validVotes
  };
}

function getListenerCount(film, aggregates = {}) {
  const audienceData = aggregates.audienceScores?.[film.id] ?? audienceScores[film.id];
  const listenerVotesRaw = audienceData?.listener_count
    ?? film.listenerVotes
    ?? (Array.isArray(film.listenerRatings) ? film.listenerRatings.length : null);
  const listenerVotes = Number(listenerVotesRaw);
  return Number.isFinite(listenerVotes) ? listenerVotes : 0;
}

function getListenerAverage10(film, aggregates = {}) {
  const audienceData = aggregates.audienceScores?.[film.id] ?? audienceScores[film.id];
  const weightedPercent = audienceData?.weighted_percent
    ?? film.listenerScore
    ?? film.listenerRating
    ?? film.listenerPercent
    ?? film.listener_score;
  const normalized = normaliseScoreToPercent(weightedPercent);
  return normalized !== null ? normalized / 10 : null;
}

function getKevRating10(film, _aggregates = {}) {
  const kevValue = film.kev_rating_10
    ?? film.kevRating10
    ?? film.kevScore
    ?? film.score;
  const normalized = normaliseScoreToPercent(kevValue);
  return normalized !== null ? normalized / 10 : null;
}

function normalizeFilmTitle(value) {
  return String(value || "").trim().toLowerCase();
}

function normalizeFilmTitleForMatch(value) {
  return String(value || "")
    .toLowerCase()
    .replace(/[^\p{L}\p{N}]+/gu, " ")
    .trim();
}

function findMatchingRealFilm(film, films = []) {
  if (!film?.title) return null;
  const targetTitle = normalizeFilmTitle(film.title);
  return films.find((candidate) => (
    !candidate.rob && normalizeFilmTitle(candidate.title) === targetTitle
  )) ?? null;
}

function getRottenTomatoesScore10FromFilm(film) {
  if (!film) return null;
  const directValue = film.rottenTomatoesScore
    ?? film.rtScore
    ?? film.rt_score
    ?? film.rotten_score;
  const directNormalized = normaliseScoreToPercent(directValue);
  if (directNormalized !== null) return directNormalized / 10;
  const scoreLabel = String(film.scoreLabel || "");
  if (!film.rob && scoreLabel.toLowerCase().includes("rotten")) {
    const normalized = normaliseScoreToPercent(film.score);
    return normalized !== null ? normalized / 10 : null;
  }
  return null;
}

function getRottenTomatoesScore10(film, aggregates = {}) {
  const direct = getRottenTomatoesScore10FromFilm(film);
  if (direct !== null) return direct;
  const allFilmsList = aggregates.allFilms ?? allFilms;
  if (!Array.isArray(allFilmsList)) return null;
  const matched = findMatchingRealFilm(film, allFilmsList);
  return matched ? getRottenTomatoesScore10FromFilm(matched) : null;
}

function getNewestFilmTimestamp(film) {
  const dateValue = film.podcasted_at
    ?? film.podcastedAt
    ?? film.podcastDate
    ?? film.created_at
    ?? film.createdAt
    ?? film.published_at
    ?? film.publishedAt
    ?? film.date;
  const parsed = parseTimestamp(dateValue);
  return parsed ? parsed.getTime() : null;
}

function getPodcastedAtTimestamp(film) {
  const dateValue = film.podcasted_at
    ?? film.podcastedAt
    ?? film.podcastDate
    ?? null;
  const parsed = parseTimestamp(dateValue);
  return parsed ? parsed.getTime() : null;
}

function getPodcastedDateValue(film) {
  return film?.podcasted_at
    ?? film?.podcastedAt
    ?? film?.podcastDate
    ?? null;
}

function computeStandardDeviation(values) {
  const parsed = values
    .map((value) => Number(value))
    .filter((value) => Number.isFinite(value));
  if (parsed.length < 2) return null;
  const mean = parsed.reduce((sum, value) => sum + value, 0) / parsed.length;
  const variance = parsed.reduce((sum, value) => sum + ((value - mean) ** 2), 0) / parsed.length;
  return Math.sqrt(variance);
}

function getDivisiveMetric(film) {
  const audienceData = audienceScores[film.id] || {};
  const listenerRatings = Array.isArray(film.listenerRatings)
    ? film.listenerRatings
    : (Array.isArray(audienceData.listener_ratings) ? audienceData.listener_ratings : null);

  if (listenerRatings?.length >= 2) {
    const normalisedRatings = listenerRatings
      .map(normaliseScoreToPercent)
      .filter((value) => Number.isFinite(value));
    if (normalisedRatings.length >= 2) {
      return computeStandardDeviation(normalisedRatings);
    }
  }

  const spreadRaw = audienceData.rating_spread
    ?? film.ratingSpread
    ?? film.listenerRatingSpread;
  const spreadNorm = normaliseScoreToPercent(spreadRaw);
  if (spreadNorm !== null) return spreadNorm;

  const minRating = normaliseScoreToPercent(audienceData.min_rating ?? film.listenerMinRating ?? film.listenerRatingMin);
  const maxRating = normaliseScoreToPercent(audienceData.max_rating ?? film.listenerMaxRating ?? film.listenerRatingMax);
  if (minRating !== null && maxRating !== null && maxRating >= minRating) {
    return maxRating - minRating;
  }

  return null;
}

function getDivisiveAwardMetric(film, aggregates = {}) {
  const audienceData = aggregates.audienceScores?.[film.id] ?? audienceScores[film.id] ?? {};
  const hasPerVoteRatings = Array.isArray(film.listenerRatings)
    || Array.isArray(audienceData.listener_ratings);
  const baseSpread = getDivisiveMetric(film);
  if (!Number.isFinite(baseSpread)) return null;
  if (hasPerVoteRatings) return baseSpread;
  const listenerCount = getListenerCount(film, aggregates);
  return listenerCount > 0 ? baseSpread * listenerCount : baseSpread;
}

function compareInsightCandidates(a, b) {
  if (b.metric !== a.metric) return b.metric - a.metric;
  if (b.votes !== a.votes) return b.votes - a.votes;
  return a.title.localeCompare(b.title, "en-GB", { sensitivity: "base" });
}

function compareDivisiveCandidates(a, b) {
  if (b.weightedDiv !== a.weightedDiv) return b.weightedDiv - a.weightedDiv;
  // Tie-breakers: bigger gap vs Kev, more votes, then alphabetical title.
  if (b.gapVsKev !== a.gapVsKev) return b.gapVsKev - a.gapVsKev;
  if (b.votes !== a.votes) return b.votes - a.votes;
  return a.title.localeCompare(b.title, "en-GB", { sensitivity: "base" });
}

function computeInsightRosettes(films) {
  const candidates = films
    .filter((film) => film.rob)
    .map((film) => {
      const insight = getInsightEligibleData(film);
      return {
        film,
        title: String(film.title || ""),
        kevScoreNorm: insight.kevScoreNorm,
        listenerScoreNorm: insight.listenerScoreNorm,
        votes: insight.listenerVotes
      };
    });

  const ratedCandidates = candidates.filter((candidate) => (
    candidate.votes >= INSIGHT_MIN_VOTES
    && candidate.kevScoreNorm !== null
    && candidate.listenerScoreNorm !== null
  ));

  const underratedPool = ratedCandidates
    .map((candidate) => ({
      ...candidate,
      metric: candidate.listenerScoreNorm - candidate.kevScoreNorm
    }))
    .filter((candidate) => candidate.metric >= INSIGHT_GAP_MIN)
    .sort(compareInsightCandidates);

  const overratedPool = ratedCandidates
    .map((candidate) => ({
      ...candidate,
      metric: candidate.kevScoreNorm - candidate.listenerScoreNorm
    }))
    .filter((candidate) => candidate.metric >= INSIGHT_GAP_MIN)
    .sort(compareInsightCandidates);

  const divisivePool = candidates
    .map((candidate) => {
      const listenerAvg10 = Number(getListenerAverage10(candidate.film, { audienceScores }));
      const kevAvg10 = Number(getKevRating10(candidate.film, { audienceScores }));
      const gapVsKev = Number.isFinite(listenerAvg10) && Number.isFinite(kevAvg10)
        ? Math.abs(listenerAvg10 - kevAvg10)
        : -1;
      const baseDiv = candidate.votes >= INSIGHT_MIN_VOTES ? getDivisiveMetric(candidate.film) : null;
      // Weight divisiveness by vote volume so tiny samples do not beat broadly divisive films.
      const weightedDiv = Number.isFinite(baseDiv)
        ? baseDiv * Math.log10(candidate.votes + 1)
        : null;
      return {
        ...candidate,
        listenerAvg10,
        kevAvg10,
        gapVsKev,
        baseDiv,
        weightedDiv
      };
    })
    .filter((candidate) => (
      Number.isFinite(candidate.baseDiv)
      && candidate.baseDiv >= INSIGHT_DIV_MIN
      && Number.isFinite(candidate.weightedDiv)
      && candidate.weightedDiv > 0
    ))
    .sort(compareDivisiveCandidates);

  return {
    underratedFilmId: underratedPool[0]?.film.id ?? null,
    overratedFilmId: overratedPool[0]?.film.id ?? null,
    divisiveFilmId: divisivePool[0]?.film.id ?? null
  };
}

function getListenerRatingValue(film) {
  const audienceValue = getPercentRaw(audienceScores[film.id]?.weighted_percent);
  if (audienceValue !== null) return audienceValue;
  const fallbackValue = parseListenerRatingValue(
    film.listenerRating ?? film.listenerPercent ?? film.listenerScore ?? film.listener_score
  );
  const normalized = normaliseScoreToPercent(fallbackValue);
  return normalized !== null ? normalized : -1;
}

function getCompositeScore(film) {
  const kevScore = Number(film.kevScore);
  const rottenScore = Number(film.rottenTomatoesScore);
  const hasKev = Number.isFinite(kevScore);
  const hasRotten = Number.isFinite(rottenScore);
  // Composite rating uses equal weighting, but fall back gracefully if data is missing.
  if (hasKev && hasRotten) {
    return (kevScore + rottenScore) / 2;
  }
  if (hasKev) return kevScore;
  if (hasRotten) return rottenScore;
  return 0;
}

function getTopAwardWinners(films, getValue) {
  let bestValue = null;
  let winners = [];
  films.forEach((film) => {
    const value = getValue(film);
    if (!Number.isFinite(value)) return;
    if (bestValue === null || value > bestValue) {
      bestValue = value;
      winners = [film];
      return;
    }
    if (value === bestValue) {
      winners.push(film);
    }
  });
  return winners;
}

function getBestSingleWinner(films, getMetric, getVotes) {
  let bestFilm = null;
  let bestMetric = null;
  let bestVotes = null;
  let bestTitle = "";
  films.forEach((film) => {
    const metric = getMetric(film);
    if (!Number.isFinite(metric)) return;
    const votes = getVotes(film);
    const safeVotes = Number.isFinite(votes) ? votes : 0;
    const title = String(film.title || "");
    if (bestFilm === null) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestTitle = title;
      return;
    }
    if (metric > bestMetric) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestTitle = title;
      return;
    }
    if (metric === bestMetric && safeVotes > bestVotes) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestTitle = title;
      return;
    }
    if (metric === bestMetric && safeVotes === bestVotes) {
      const comparison = title.localeCompare(bestTitle, "en-GB", { sensitivity: "base" });
      if (comparison < 0) {
        bestFilm = film;
        bestMetric = metric;
        bestVotes = safeVotes;
        bestTitle = title;
      }
    }
  });
  return bestFilm ? [bestFilm] : [];
}

function getBestSingleWinnerWithTiebreak(films, getMetric, getVotes, getTie) {
  let bestFilm = null;
  let bestMetric = null;
  let bestVotes = null;
  let bestGap = -1;
  let bestTitle = "";
  films.forEach((film) => {
    const metric = getMetric(film);
    if (!Number.isFinite(metric)) return;
    const votes = getVotes(film);
    const safeVotes = Number.isFinite(votes) ? votes : 0;
    const tieData = getTie ? getTie(film) : {};
    const gapVsKev = Number.isFinite(tieData?.gapVsKev) ? tieData.gapVsKev : -1;
    const title = String(tieData?.title ?? film.title ?? "");
    if (bestFilm === null) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestGap = gapVsKev;
      bestTitle = title;
      return;
    }
    if (metric > bestMetric) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestGap = gapVsKev;
      bestTitle = title;
      return;
    }
    // Tie-breakers: gap vs Kev, votes, then alphabetical title.
    if (metric === bestMetric && gapVsKev > bestGap) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestGap = gapVsKev;
      bestTitle = title;
      return;
    }
    if (metric === bestMetric && gapVsKev === bestGap && safeVotes > bestVotes) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestGap = gapVsKev;
      bestTitle = title;
      return;
    }
    if (metric === bestMetric && gapVsKev === bestGap && safeVotes === bestVotes) {
      const comparison = title.localeCompare(bestTitle, "en-GB", { sensitivity: "base" });
      if (comparison < 0) {
        bestFilm = film;
        bestMetric = metric;
        bestVotes = safeVotes;
        bestGap = gapVsKev;
        bestTitle = title;
      }
    }
  });
  return bestFilm ? [bestFilm] : [];
}

function getBestSingleWinnerLowest(films, getMetric, getVotes) {
  let bestFilm = null;
  let bestMetric = null;
  let bestVotes = null;
  let bestTitle = "";
  films.forEach((film) => {
    const metric = getMetric(film);
    if (!Number.isFinite(metric)) return;
    const votes = getVotes(film);
    const safeVotes = Number.isFinite(votes) ? votes : 0;
    const title = String(film.title || "");
    if (bestFilm === null) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestTitle = title;
      return;
    }
    if (metric < bestMetric) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestTitle = title;
      return;
    }
    if (metric === bestMetric && safeVotes > bestVotes) {
      bestFilm = film;
      bestMetric = metric;
      bestVotes = safeVotes;
      bestTitle = title;
      return;
    }
    if (metric === bestMetric && safeVotes === bestVotes) {
      const comparison = title.localeCompare(bestTitle, "en-GB", { sensitivity: "base" });
      if (comparison < 0) {
        bestFilm = film;
        bestMetric = metric;
        bestVotes = safeVotes;
        bestTitle = title;
      }
    }
  });
  return bestFilm ? [bestFilm] : [];
}

function getAwardsUpdatedAt(films, aggregates = {}) {
  const candidates = [];
  if (awardsLastUpdatedAt) candidates.push(awardsLastUpdatedAt);
  films.forEach((film) => {
    const audienceData = aggregates.audienceScores?.[film.id] ?? audienceScores[film.id];
    const filmUpdated = parseTimestamp(
      film.agg_updated_at
        ?? film.aggUpdatedAt
        ?? film.aggregatedAt
        ?? film.updated_at
        ?? film.updatedAt
    );
    const audienceUpdated = parseTimestamp(
      audienceData?.agg_updated_at
        ?? audienceData?.aggUpdatedAt
        ?? audienceData?.updated_at
        ?? audienceData?.updatedAt
    );
    if (filmUpdated) candidates.push(filmUpdated);
    if (audienceUpdated) candidates.push(audienceUpdated);
  });
  if (!candidates.length) return null;
  return candidates.reduce((latest, value) => (value > latest ? value : latest));
}

function setAwardsLastUpdated(timestamp) {
  const parsed = parseTimestamp(timestamp);
  if (!parsed) return;
  if (!awardsLastUpdatedAt || parsed > awardsLastUpdatedAt) {
    awardsLastUpdatedAt = parsed;
  }
}

function shouldShowFilmAwards() {
  // Visibility gating: Robâ€™s films only, no search query, and default sort state.
  const hasDefaultSort = currentSort === "rating-desc";
  return currentFilter === "rob" && filmSearchQuery.trim() === "" && hasDefaultSort;
}

function formatAwardWinnersLine(
  winners,
  {
    emptyText = "Winner: Not enough votes yet",
    pluralLabel = "Winners",
    singularLabel = "Winner"
  } = {}
) {
  if (!winners.length) return emptyText;
  if (winners.length === 1) {
    const title = escapeHtml(String(winners[0].title || "Untitled"));
    return `${singularLabel}: ${title}`;
  }
  const titles = winners.map((winner) => escapeHtml(String(winner.title || "Untitled")));
  return `${pluralLabel}: ${titles.join(", ")}`;
}

function getVisibleAwards(films, aggregates = {}) {
  return AWARDS.filter((award) => (
    typeof award.shouldDisplay !== "function" || award.shouldDisplay(films, aggregates)
  ));
}

function setAwardsExpanded(isExpanded, { immediate = false } = {}) {
  awardsExpanded = isExpanded;
  if (!awardsSection) return;
  const toggleButton = awardsSection.querySelector(".film-awards__toggle");
  const content = awardsSection.querySelector(".film-awards__content");
  if (!toggleButton || !content) return;
  toggleButton.setAttribute("aria-expanded", String(isExpanded));
  content.setAttribute("aria-hidden", String(!isExpanded));
  const updateHeights = () => {
    content.style.maxHeight = isExpanded ? `${content.scrollHeight}px` : "0px";
    content.style.opacity = isExpanded ? "1" : "0";
  };
  if (immediate) {
    content.classList.toggle("is-open", isExpanded);
    updateHeights();
    return;
  }
  if (isExpanded) {
    content.classList.add("is-open");
    requestAnimationFrame(updateHeights);
  } else {
    requestAnimationFrame(updateHeights);
    content.addEventListener("transitionend", () => content.classList.remove("is-open"), { once: true });
  }
}

function renderFilmAwards() {
  if (!awardsSection) return;
  if (!shouldShowFilmAwards()) {
    awardsSection.innerHTML = "";
    awardsSection.hidden = true;
    awardsExpanded = false;
    return;
  }

  const robFilms = allFilms.filter((film) => film.active && film.rob);
  const awardsContext = { audienceScores, allFilms };
  const visibleAwards = getVisibleAwards(robFilms, awardsContext);
  const awardRows = visibleAwards.map((award) => {
    const winners = award.getWinners(robFilms, awardsContext);
    const winnersLine = formatAwardWinnersLine(winners, {
      emptyText: award.emptyWinnersText,
      pluralLabel: award.pluralLabel,
      singularLabel: award.singularLabel
    });
    return `
      <article class="film-award-row" data-award="${award.key}">
        <div class="film-award-meta">
          <div class="film-award-heading">
            <span class="rosette ${award.rosetteClass}">
              ${escapeHtml(award.label)}
              <span class="badge-icon" aria-hidden="true">${award.emoji}</span>
            </span>
          </div>
          <p class="film-award-description">${escapeHtml(award.description)}</p>
        </div>
        <p class="film-award-winner">${winnersLine}</p>
      </article>
    `;
  }).join("");

  awardsSection.hidden = false;
  const lastUpdatedLabel = formatAwardsUpdatedLabel(getAwardsUpdatedAt(robFilms, awardsContext));
  awardsSection.innerHTML = `
    <div class="film-awards__inner">
      <button class="film-awards__toggle" type="button" aria-expanded="false" aria-controls="${AWARDS_CONTENT_ID}">
        <span class="film-awards__heading">
          <span id="film-awards-title" class="film-awards__title">Film Awards</span>
          <span class="film-awards__updated">${lastUpdatedLabel}</span>
        </span>
        <span class="film-awards__chevron" aria-hidden="true">
          <svg viewBox="0 0 24 24" width="20" height="20" focusable="false" aria-hidden="true">
            <path fill="currentColor" d="M12 15.5a.75.75 0 0 1-.53-.22l-5.5-5.5a.75.75 0 0 1 1.06-1.06L12 13.69l4.97-4.97a.75.75 0 0 1 1.06 1.06l-5.5 5.5a.75.75 0 0 1-.53.22Z"/>
          </svg>
        </span>
      </button>
      <div id="${AWARDS_CONTENT_ID}" class="film-awards__content" role="region" aria-labelledby="film-awards-title" aria-hidden="true">
        <div class="film-awards__list">
          ${awardRows}
        </div>
      </div>
    </div>
  `;

  const toggleButton = awardsSection.querySelector(".film-awards__toggle");
  if (toggleButton) {
    toggleButton.addEventListener("click", () => {
      setAwardsExpanded(!awardsExpanded);
    });
  }
  setAwardsExpanded(awardsExpanded, { immediate: true });
}

function getFilteredFilms() {
  let films = allFilms.filter(f => f.active);
  if (currentFilter === "rob") films = films.filter(f => f.rob);
  if (currentFilter === "real") films = films.filter(f => !f.rob);
  if (filmSearchQuery) {
    const normalizedQuery = filmSearchQuery.toLowerCase();
    films = films.filter((film) => {
      const title = String(film.title || "").toLowerCase();
      const starring = String(film.starring || "").toLowerCase();
      return title.includes(normalizedQuery) || starring.includes(normalizedQuery);
    });
  }
  return films;
}

function buildRobFilmIndexes(films) {
  const robBySlug = new Map();
  const robByTitle = new Map();
  films.filter((film) => film.rob).forEach((film) => {
    if (typeof film.id === "string" && film.id.startsWith("rob-")) {
      robBySlug.set(film.id.slice(4), film);
    }
    const normalizedTitle = normalizeFilmTitleForMatch(film.title);
    if (!normalizedTitle) return;
    const list = robByTitle.get(normalizedTitle) ?? [];
    list.push(film);
    robByTitle.set(normalizedTitle, list);
  });
  return { robBySlug, robByTitle };
}

function resolveRobMatchForReal(realFilm, indexes, ambiguousMatches) {
  if (!realFilm) return null;
  if (typeof realFilm.id === "string" && realFilm.id.startsWith("real-")) {
    const robMatch = indexes.robBySlug.get(realFilm.id.slice(5));
    if (robMatch) return robMatch;
  }
  const normalizedTitle = normalizeFilmTitleForMatch(realFilm.title);
  if (!normalizedTitle) return null;
  const matches = indexes.robByTitle.get(normalizedTitle) ?? [];
  if (matches.length > 1) {
    ambiguousMatches.push({ title: realFilm.title, ids: matches.map((film) => film.id) });
    return null;
  }
  return matches[0] ?? null;
}

function assignPodcastedDates(films) {
  const indexes = buildRobFilmIndexes(films);
  const unmatchedReals = [];
  const ambiguousMatches = [];

  films.forEach((film) => {
    if (film.rob) {
      film.podcasted_at = film.podcasted_at ?? film.podcastDate ?? film.podcastedAt ?? null;
      return;
    }

    const match = resolveRobMatchForReal(film, indexes, ambiguousMatches);
    if (match?.podcasted_at || match?.podcastDate || match?.podcastedAt) {
      // Inherit the Rob film's podcasted date so real films stay in sync.
      film.podcasted_at = match.podcasted_at ?? match.podcastDate ?? match.podcastedAt ?? null;
      return;
    }
    film.podcasted_at = null;
    unmatchedReals.push(film);
  });

  const shouldWarn = ["localhost", "127.0.0.1"].includes(window.location.hostname);
  if (shouldWarn && (unmatchedReals.length || ambiguousMatches.length)) {
    const unmatchedTitles = unmatchedReals.map((film) => film.title).filter(Boolean);
    const ambiguousTitles = ambiguousMatches.map((entry) => entry.title).filter(Boolean);
    console.warn(
      "Unmatched real films for podcast dates.",
      { unmatchedTitles, ambiguousTitles }
    );
  }
}

function sortFilms(films) {
  if (currentSort === "rating-asc") {
    return stableSortFilms(films, (a, b) => getCompositeScore(a) - getCompositeScore(b));
  }
  if (currentSort === "rating-desc") {
    return stableSortFilms(films, (a, b) => getCompositeScore(b) - getCompositeScore(a));
  }
  if (currentSort === "listener-asc") {
    return stableSortFilms(films, (a, b) => {
      const aScore = getListenerRatingValue(a);
      const bScore = getListenerRatingValue(b);
      if (aScore === -1 && bScore === -1) return 0;
      if (aScore === -1) return 1;
      if (bScore === -1) return -1;
      return aScore - bScore;
    });
  }
  if (currentSort === "listener-desc") {
    return stableSortFilms(films, (a, b) => {
      const aScore = getListenerRatingValue(a);
      const bScore = getListenerRatingValue(b);
      if (aScore === -1 && bScore === -1) return 0;
      if (aScore === -1) return 1;
      if (bScore === -1) return -1;
      return bScore - aScore;
    });
  }
  if (currentSort === "podcast-desc" || currentSort === "podcast-asc") {
    const fallbackComparator = (a, b) => {
      const scoreDiff = getCompositeScore(b) - getCompositeScore(a);
      if (scoreDiff !== 0) return scoreDiff;
      return String(a.title || "").localeCompare(String(b.title || ""));
    };
    const direction = currentSort === "podcast-desc" ? -1 : 1;
    return stableSortFilms(films, (a, b) => {
      const aDate = getPodcastedAtTimestamp(a);
      const bDate = getPodcastedAtTimestamp(b);
      if (aDate === null && bDate === null) return fallbackComparator(a, b);
      if (aDate === null) return 1;
      if (bDate === null) return -1;
      if (aDate !== bDate) return (aDate - bDate) * direction;
      return fallbackComparator(a, b);
    });
  }
  return stableSortFilms(films, (a, b) => getCompositeScore(b) - getCompositeScore(a));
}

function getSortSelect() {
  return document.getElementById("sortSelect");
}

function getFilterSelect() {
  return document.getElementById("filmFilter");
}

function updateListenerSortAvailability() {
  const sortSelect = getSortSelect();
  if (!sortSelect) return;
  const listenerOptions = Array.from(sortSelect.querySelectorAll("[data-listener-option]"));
  const allowListenerSort = currentFilter !== "real";
  // Hide/disable listener sorts when Real Films is selected to avoid invalid options.
  listenerOptions.forEach((option) => {
    option.hidden = !allowListenerSort;
    option.disabled = !allowListenerSort;
  });
  if (!allowListenerSort && currentSort.startsWith("listener")) {
    currentSort = "rating-desc";
    sortSelect.value = currentSort;
  }
}

function syncFilterControls() {
  const filterSelect = getFilterSelect();
  const sortSelect = getSortSelect();
  const { input } = getFilmSearchElements();
  if (filterSelect) filterSelect.value = currentFilter;
  if (sortSelect) sortSelect.value = currentSort;
  if (input) input.value = filmSearchQuery;
  updateListenerSortAvailability();
  updateFilmSearchClearVisibility();
  updateMobileSelectIcons();
}

async function refreshListenerScores(films) {
  const robIds = films.filter(f => f.rob).map(f => f.id);
  if (!supabaseClient || robIds.length === 0) return;
  const fetchKey = [...robIds].sort().join("|");
  if (fetchKey === lastScoreFetchKey) return;
  lastScoreFetchKey = fetchKey;

  const { data, error } = await supabaseClient
    .from("film_listener_scores")
    .select("film_id, listener_score")
    .in("film_id", robIds);

  if (error) {
    console.error("Failed to fetch listener scores.", error);
    statusEl.textContent = `Score fetch failed: ${error.message || "Unknown error"}`;
    return;
  }

  data.forEach(row => {
    listenerScores[row.film_id] = row.listener_score ?? 0;
    const film = allFilms.find(entry => entry.id === row.film_id);
    if (film) film.listener_score = row.listener_score ?? 0;
  });
}

async function fetchAudienceScores() {
  if (!supabaseClient) return;
  const { data, error } = await supabaseClient
    .from("film_scores_v1")
    .select("film_id, weighted_percent, listener_count, agg_updated_at");

  if (error) {
    console.error("Failed to fetch audience scores.", error);
    return;
  }

  let latestAggregate = null;
  data.forEach(row => {
    audienceScores[row.film_id] = {
      weighted_percent: row.weighted_percent,
      listener_count: row.listener_count,
      agg_updated_at: row.agg_updated_at
    };
    const parsed = parseTimestamp(row.agg_updated_at);
    if (parsed && (!latestAggregate || parsed > latestAggregate)) {
      latestAggregate = parsed;
    }
  });
  if (latestAggregate) {
    setAwardsLastUpdated(latestAggregate);
  }
}

async function fetchListenerVotes(films = []) {
  if (!supabaseClient) return {};
  const robIds = films.filter((film) => film.rob).map((film) => film.id);
  if (!robIds.length) return {};
  const votesByFilmId = {};
  const pageSize = 1000;
  let fromIndex = 0;
  while (true) {
    const toIndex = fromIndex + pageSize - 1;
    const { data, error } = await supabaseClient
      .from("film_votes")
      .select("film_id, rating")
      .in("film_id", robIds)
      .range(fromIndex, toIndex);
    if (error) {
      console.error("Failed to fetch listener votes.", error);
      break;
    }
    if (!data?.length) break;
    data.forEach((row) => {
      if (!votesByFilmId[row.film_id]) {
        votesByFilmId[row.film_id] = [];
      }
      votesByFilmId[row.film_id].push(row.rating);
    });
    if (data.length < pageSize) break;
    fromIndex += pageSize;
  }

  Object.entries(votesByFilmId).forEach(([filmId, ratings]) => {
    const existing = audienceScores[filmId] ?? {};
    audienceScores[filmId] = {
      ...existing,
      listener_ratings: ratings
    };
  });

  return votesByFilmId;
}

async function refreshListenerVotesForFilm(filmId) {
  if (!supabaseClient || !filmId) return null;
  const pageSize = 1000;
  let fromIndex = 0;
  const ratings = [];
  while (true) {
    const toIndex = fromIndex + pageSize - 1;
    const { data, error } = await supabaseClient
      .from("film_votes")
      .select("film_id, rating")
      .eq("film_id", filmId)
      .range(fromIndex, toIndex);
    if (error) {
      console.error("Failed to refresh listener votes.", error);
      return null;
    }
    if (!data?.length) break;
    data.forEach((row) => ratings.push(row.rating));
    if (data.length < pageSize) break;
    fromIndex += pageSize;
  }
  const existing = audienceScores[filmId] ?? {};
  audienceScores[filmId] = {
    ...existing,
    listener_ratings: ratings
  };
  return ratings;
}

async function fetchAwardsLastUpdated() {
  // Timestamp logic: use the latest available aggregation timestamp when present.
  try {
    if (awardsLastUpdatedAt) return;
    const response = await fetch("/assets/data/films/votes.json", { cache: "no-store" });
    if (!response.ok) return;
    const payload = await response.json();
    const parsed = parseTimestamp(payload?.updatedAt ?? payload?.updated_at);
    if (parsed) {
      setAwardsLastUpdated(parsed);
    }
  } catch (error) {
    console.warn("Failed to load awards updated timestamp.", error);
  }
}

function triggerAudienceNudge(target) {
  if (!target) return;
  target.classList.remove("audience-nudge");
  void target.offsetWidth;
  target.classList.add("audience-nudge");
  target.addEventListener(
    "animationend",
    () => {
      target.classList.remove("audience-nudge");
    },
    { once: true }
  );
}

function updateAudienceScoreUI(filmId, audienceData, options = {}) {
  const { highlight = false } = options;
  const audienceRaw = getPercentRaw(audienceData?.weighted_percent);
  const audiencePercent = audienceRaw !== null ? roundPercent(audienceRaw) : null;
  const audienceVotes = Number(audienceData?.listener_count ?? 0);
  const audienceLabel = audiencePercent !== null
    ? `Audience: ${audiencePercent}%`
    : "Audience: â€”";
  const audienceVotesLabel = audiencePercent !== null
    ? `${audienceVotes} vote(s)`
    : "0 votes";

  document.querySelectorAll(`.film-card[data-film-id="${filmId}"]`).forEach(card => {
    const audienceLabelEl = card.querySelector("[data-audience-label]");
    const audienceVotesEl = card.querySelector("[data-audience-votes]");
    const scoreRow = card.querySelector("[data-score-row]");
    if (audienceLabelEl) {
      audienceLabelEl.textContent = audienceLabel;
      if (highlight) triggerAudienceNudge(audienceLabelEl);
    }
    if (audienceVotesEl) {
      audienceVotesEl.textContent = audienceVotesLabel;
    }
    if (scoreRow) {
      const audienceValueEl = scoreRow.querySelector('[data-score-half="audience"] [data-score-number]');
      scoreRow.dataset.audienceScore = audienceRaw ?? "";
      if (audienceValueEl) {
        audienceValueEl.textContent = formatPercentLabel(audienceRaw);
      }
      applyScoreCardHighlight(scoreRow);
    }
  });
}

function applyScoreCardHighlight(scoreRow) {
  if (!scoreRow) return;
  const kevValue = Number(scoreRow.dataset.kevScore);
  const audienceValue = Number(scoreRow.dataset.audienceScore);
  const audienceTrend = scoreRow.querySelector('[data-score-trend]');
  if (!audienceTrend) return;

  audienceTrend.textContent = "";
  audienceTrend.classList.remove("score-trend--up", "score-trend--down");

  if (!Number.isFinite(kevValue) || !Number.isFinite(audienceValue)) return;

  if (audienceValue > kevValue) {
    audienceTrend.textContent = "â–²";
    audienceTrend.classList.add("score-trend--up");
  } else if (audienceValue < kevValue) {
    audienceTrend.textContent = "â–¼";
    audienceTrend.classList.add("score-trend--down");
  }
}

async function refreshAudienceScoreForFilm(filmId) {
  if (!supabaseClient) return null;
  const { data, error } = await supabaseClient
    .from("film_scores_v1")
    .select("film_id, weighted_percent, listener_count")
    .eq("film_id", filmId)
    .maybeSingle();

  if (error) {
    console.error("Failed to refresh audience score.", error);
    return null;
  }

  if (!data) return null;

  audienceScores[filmId] = {
    weighted_percent: data.weighted_percent,
    listener_count: data.listener_count
  };
  updateAudienceScoreUI(filmId, audienceScores[filmId], { highlight: true });
  return data;
}

async function render(options = {}) {
  container.innerHTML = "";
  closeOpenTooltip();

  let films = getFilteredFilms();
  const showListenerUI = currentFilter !== "real";

  if (!options.skipScoreRefresh) {
    await refreshListenerScores(films);
    films = getFilteredFilms();
  }

  const allResults = sortFilms(films);

  const robFilmsAll = allFilms.filter(f => f.active && f.rob);
  const awardsContext = { audienceScores, allFilms };
  const visibleAwards = getVisibleAwards(robFilmsAll, awardsContext);
  const awardWinnersByKey = Object.fromEntries(
    visibleAwards.map((award) => ([
      award.key,
      new Set(award.getWinners(robFilmsAll, awardsContext).map((film) => film.id))
    ]))
  );

  currentTotal = allResults.length;
  const visibleFilms = allResults.slice(0, visibleCount);
  const totalFilms = allResults.length;
  const renderOffset = 0;
  const isPodcastSort = currentSort === "podcast-desc" || currentSort === "podcast-asc";
  const isDescendingRank = currentSort === "rating-desc" || currentSort === "listener-desc";
  const isAscendingRank = currentSort === "rating-asc" || currentSort === "listener-asc";

  visibleFilms.forEach((film, index) => {
    const globalIndex = index + renderOffset;
    let rankText = "â€”";
    if (isDescendingRank) {
      rankText = String(globalIndex + 1);
    } else if (isAscendingRank) {
      rankText = String(totalFilms - globalIndex);
    } else if (isPodcastSort) {
      rankText = timeSinceLabel(getPodcastedDateValue(film));
    } else {
      rankText = String(globalIndex + 1);
    }
    const rankLabel = isPodcastSort ? rankText : `#${rankText}`;
    const listenerScore = listenerScores[film.id] ?? 0;
    const audienceData = audienceScores[film.id];
    const audienceRaw = getPercentRaw(audienceData?.weighted_percent);
    const audiencePercent = audienceRaw !== null ? roundPercent(audienceRaw) : null;
    const audienceVotes = Number(audienceData?.listener_count ?? 0);
    const audienceLabel = audiencePercent !== null
      ? `Audience: ${audiencePercent}%`
      : "Audience: â€”";
    const audienceVotesLabel = audiencePercent !== null
      ? `${audienceVotes} vote(s)`
      : "0 votes";
    const kevScoreDisplay = formatPercentLabel(film.score);
    const audienceScoreDisplay = formatPercentLabel(audienceRaw);
    const storedRating = localRatings[film.id] ?? null;
    const transcriptButton = film.transcriptTxt
      ? `<button class="transcript-link" type="button" data-transcript-txt="${film.transcriptTxt}" data-transcript-title="${film.title}">View transcript</button>`
      : "";
    const card = document.createElement("div");
    card.className = `film-card ${film.rob ? "rob-film" : ""}`;
    card.dataset.filmId = film.id;
    card.id = `film-${film.id}`;

    const rosettes = [
      {
        className: film.rob ? "rob" : "real",
        label: film.rob ? "Robâ€™s Film" : "Real Film",
        icon: ""
      }
    ];

    if (film.rob) {
      visibleAwards.forEach((award) => {
        if (!awardWinnersByKey[award.key]?.has(film.id)) return;
        rosettes.push({
          className: award.rosetteClass,
          label: award.label,
          icon: `<span class="badge-icon" aria-hidden="true">${award.emoji}</span>`,
          title: award.description || ""
        });
      });
    }

    if (Array.isArray(film.rosettes)) {
      film.rosettes.forEach((rosette) => {
        if (!rosette?.label) return;
        rosettes.push({
          className: rosette.className || "other",
          label: rosette.label,
          icon: rosette.icon || "",
          title: rosette.title || ""
        });
      });
    }

    const rosetteMarkup = rosettes
      .map(({ className, label, icon, title }) => {
        const iconMarkup = icon ? ` ${icon.trim()}` : "";
        return `<span class="rosette ${className}"${title ? ` title="${escapeHtml(title)}"` : ""}>${label}${iconMarkup}</span>`;
      })
      .join("");

    card.innerHTML = `
      <div class="hero-rank">${rankLabel}</div>
      <div class="rosette-stack" aria-label="Episode rosettes">
        ${rosetteMarkup}
      </div>

      <div class="hero-layout">
        <div class="film-poster-wrapper">
          <div class="poster-wrap">
            <img src="${film.poster}" class="poster" />
          </div>
        </div>

      ${film.rob ? `
        <div class="film-details rob-details">
          <div class="detail-row">
            <div>
              <h2 class="detail-title">
                ${film.title}<br>
                <span class="variant">[Robâ€™s Version]</span>
              </h2>
              <p class="meta-line">
                Starring: ${film.starring}
              </p>
              <p class="meta-line">Podcasted: ${formatUkDate(film.podcastDate)}</p>
            </div>

            <div class="score-row" data-score-row data-kev-score="${film.score}" data-audience-score="${audienceRaw ?? ""}">
              <div class="score-card score-card--stat" data-score-card="kev">
                <div class="score-stat" data-score-half="kev">
                  <div class="score-label">Kevâ€™s Score</div>
                  <div class="score-value" data-score-value>${kevScoreDisplay}</div>
                </div>
              </div>
              <div class="score-card score-card--stat" data-score-card="audience">
                <div class="score-stat" data-score-half="audience">
                  <div class="score-label">Listener Score</div>
                  <div class="score-value" data-score-value>
                    <span data-score-number>${audienceScoreDisplay}</span><span class="score-trend" data-score-trend aria-hidden="true"></span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="divider"></div>

          <section class="bars" aria-label="Ratings">
            <div class="bar-row">
              <label>Coherence</label>
              <div class="track"><div class="fill" style="width:${film.coherence * 10}%"></div></div>
              <strong>${film.coherence}/10</strong>
            </div>
            <div class="bar-row">
              <label>Entertainment</label>
              <div class="track"><div class="fill" style="width:${film.entertainment * 10}%"></div></div>
              <strong>${film.entertainment}/10</strong>
            </div>
            <div class="bar-row">
              <label>Originality</label>
              <div class="track"><div class="fill" style="width:${film.originality * 10}%"></div></div>
              <strong>${film.originality}/10</strong>
            </div>
          </section>

          <p class="synopsis">${film.summary}</p>

          <div class="cta">
            <div class="cta-actions">
              <a class="button" href="${film.link}" target="_blank" aria-label="Play episode">â–¶ï¸ Play now</a>
              ${transcriptButton}
            </div>
            <div class="rating-panel ${storedRating ? "is-voted" : ""}" data-rating-panel data-film-id="${film.id}">
              <div class="rating-shell">
                <div class="rating-header">
                  <div class="rating-meta">
                    <span class="rating-label">YOUR RATING</span>
                    <span class="rating-output" data-rating-output>${storedRating ? `${storedRating}/10` : "Vote now"}</span>
                  </div>
                </div>
                <input class="rating-slider" type="range" min="1" max="10" step="1" value="${storedRating ?? 5}" data-rating-slider data-film-id="${film.id}" aria-label="Your rating for ${film.title}">
                <span class="rating-tick" aria-hidden="true">âœ“</span>
              </div>
              <div class="rating-error" role="status" aria-live="polite" hidden></div>
            </div>
          </div>
        </div>
      ` : `
        <div class="film-details real-details">
          <div class="detail-row">
            <div>
              <h2 class="detail-title">${film.title}</h2>
              ${film.director ? `<p class="meta-line">Directed by ${film.director}</p>` : ""}
              <p class="meta-line">Starring: ${film.starring}</p>
              ${showListenerUI ? `
                <div class="audience-score">
                  <p class="audience-line" data-audience-label>${audienceLabel}</p>
                  <p class="audience-line" data-audience-votes>${audienceVotesLabel}</p>
                </div>
              ` : ""}
            </div>
            <aside class="badge rt-badge" aria-label="Rotten Tomatoes score">
              <div class="badge-label">Rotten Tomatoes</div>
              <div class="badge-value">ðŸ… ${kevScoreDisplay}</div>
            </aside>
          </div>

          <div class="divider"></div>

          <p class="synopsis">${film.summary}</p>

          <div class="cta">
            <a class="btn rt" href="${film.link}" target="_blank">Rotten Tomatoes</a>
            ${transcriptButton}
          </div>
        </div>
      `}
      </div>
    `;

    container.appendChild(card);
    applyScoreCardHighlight(card.querySelector("[data-score-row]"));
  });

  updateFilmSearchSuggestions(currentTotal);
  updateFilmSearchLabel(currentTotal);
  updateStatus(visibleFilms.length, currentTotal);
  renderFilmAwards();
  updateLoadingState(false);
  updateSentinelVisibility();
}

function getFilmSearchElements() {
  return {
    toggle: document.getElementById("filmSearchToggle"),
    row: document.getElementById("filmSearchRow"),
    input: document.getElementById("filmSearchInput"),
    clear: document.getElementById("filmSearchClear"),
    searchField: document.querySelector("#filmSearchRow .search-field"),
    suggestions: document.getElementById("filmSearchSuggestions"),
    label: document.getElementById("filmSearchLabel")
  };
}

function setFilmSearchQuery(value, { keepFocus = false } = {}) {
  const { input } = getFilmSearchElements();
  if (!input) return;
  input.value = value;
  filmSearchQuery = value.trim();
  refreshSearchFilterToggleState();
  updateFilmSearchClearVisibility();
  resetPagination();
  render();
  if (keepFocus) {
    input.focus({ preventScroll: true });
  }
}

function updateFilmSearchClearVisibility() {
  const { clear, input, searchField } = getFilmSearchElements();
  if (!clear || !input) return;
  const hasValue = input.value.trim().length > 0;
  const isFocused = document.activeElement === input;
  const isActive = hasValue || isFocused;
  clear.hidden = !isActive;
  if (searchField) {
    searchField.classList.toggle("is-active", isActive);
  }
}

function isMobileViewport() {
  return window.matchMedia("(max-width: 768px)").matches;
}

function updateSelectIconState(select) {
  const field = select?.closest(".select-field");
  if (!field || !select) return;
  const defaultValue = select.dataset.defaultValue ?? select.querySelector("option")?.value ?? "";
  field.classList.toggle("has-nondefault", select.value !== defaultValue);
}

function updateMobileSelectIcons() {
  updateSelectIconState(getFilterSelect());
  updateSelectIconState(getSortSelect());
}

function hasAdvancedFiltersApplied() {
  return Boolean((filmSearchQuery && filmSearchQuery.length) || currentSort !== "rating-desc");
}

function refreshSearchFilterToggleState() {
  const { toggle, row } = getFilmSearchElements();
  if (!toggle) return;
  const isOpen = Boolean(row?.classList.contains("is-open"));
  toggle.classList.toggle("is-active", isOpen);
  toggle.classList.toggle("has-filters", hasAdvancedFiltersApplied());
}

function setFilmSearchOpen(isOpen) {
  const { toggle, row } = getFilmSearchElements();
  const controls = toggle?.closest(".controls");
  if (!row || !toggle || !controls) return;

  row.classList.toggle("is-open", isOpen);
  row.setAttribute("aria-hidden", String(!isOpen));
  toggle.setAttribute("aria-expanded", String(isOpen));
  controls.classList.toggle("mobile-filters-open", isOpen);
  refreshSearchFilterToggleState();
}

function clearFilmSearchSuggestions() {
  const { suggestions } = getFilmSearchElements();
  if (suggestions) suggestions.textContent = "";
}

function updateFilmSearchSuggestions(matchCount) {
  const { suggestions } = getFilmSearchElements();
  if (!suggestions) return;
  suggestions.textContent = "";
}

function updateFilmSearchLabel(resultCount = 0) {
  const { label } = getFilmSearchElements();
  if (!label) return;
  const hasSearchQuery = filmSearchQuery.length > 0;
  label.textContent = hasSearchQuery
    ? `Search - ${resultCount} results`
    : "Search";
}


function closeFilmSearch({ resetInput = false } = {}) {
  const { input } = getFilmSearchElements();
  setFilmSearchOpen(false);
  if (resetInput && input) {
    input.value = "";
  }
}

function toggleFilmSearch() {
  const { row, input } = getFilmSearchElements();
  if (!row) return;
  const isOpen = !row.classList.contains("is-open");
  const isDesktopOrTablet = !isMobileViewport();
  if (!isOpen && isDesktopOrTablet) {
    setFilmSearchQuery("");
  }
  setFilmSearchOpen(isOpen);
  if (isOpen && input) {
    input.focus();
  }
}

async function loadFilms() {
  try {
    const films = await loadFilmsData();
    films.forEach((film, index) => {
      if (film.robFilm && film.rob === undefined) {
        film.rob = film.robFilm;
      }
      if (film.realFilm && film.rob === undefined) {
        film.rob = !film.realFilm;
      }
      if (film.rob) calcRobScore(film);
      if (!film.rob && film.rottenTomatoesScore === undefined && Number.isFinite(Number(film.score))) {
        film.rottenTomatoesScore = Number(film.score);
      }
      if (film.rob && film.kevScore === undefined && Number.isFinite(Number(film.score))) {
        film.kevScore = Number(film.score);
      }
      film.originalIndex = index;
    });

    assignPodcastedDates(films);
    allFilms = films;
    lastScoreFetchKey = "";     // force a fetch on first render
    resetPagination();
    await fetchAwardsLastUpdated();
    await fetchAudienceScores();
    await fetchListenerVotes(films);
    await render();
    syncFilterControls();
    updatePodcastEpisodeSchema();

  } catch (err) {
    console.error(err);
    statusEl.textContent = "Couldnâ€™t load films.";
  }
}

document.addEventListener("DOMContentLoaded", () => {
  document.addEventListener("header:ready", () => {
    syncFilterControls();
    const shouldExpand = isMobileViewport() && hasAdvancedFiltersApplied();
    setFilmSearchOpen(shouldExpand);
    refreshSearchFilterToggleState();
    updateFilmSearchLabel(currentTotal);
    updateFilmSearchClearVisibility();
  });

  document.addEventListener("click", (event) => {
    if (event.target?.closest("#filmSearchToggle")) {
      toggleFilmSearch();
      return;
    }
  });

  document.addEventListener("input", (event) => {
    if (event.target?.id !== "filmSearchInput") return;
    setFilmSearchQuery(event.target.value);
  });

  document.addEventListener("focusin", (event) => {
    if (event.target?.id !== "filmSearchInput") return;
    updateFilmSearchClearVisibility();
  });

  document.addEventListener("focusout", (event) => {
    if (event.target?.id !== "filmSearchInput") return;
    updateFilmSearchClearVisibility();
  });

  document.addEventListener("keydown", (event) => {
    if (event.target?.id !== "filmSearchInput" || event.key !== "Escape") return;
    if (!event.target.value.trim()) return;
    event.preventDefault();
    setFilmSearchQuery("", { keepFocus: false });
    event.target.blur();
  });

  document.addEventListener("click", (event) => {
    const clearButton = event.target?.closest("#filmSearchClear");
    if (!clearButton) return;
    setFilmSearchQuery("", { keepFocus: false });
    getFilmSearchElements().input?.blur();
  });

  document.addEventListener("change", (event) => {
    if (event.target?.id === "filmFilter") {
      currentFilter = event.target.value;
      updateListenerSortAvailability();
      refreshSearchFilterToggleState();
      resetPagination();
      render();
      updateMobileSelectIcons();
    }
    if (event.target?.id === "sortSelect") {
      currentSort = event.target.value;
      refreshSearchFilterToggleState();
      resetPagination();
      render();
      updateMobileSelectIcons();
    }
  });

container.addEventListener("input", (event) => {
  const slider = event.target.closest(".rating-slider");
  if (!slider) return;
  const panel = slider.closest(".rating-panel");
  if (!panel) return;
  const value = Number(slider.value);
  updateRatingOutput(panel, value);
});

container.addEventListener("change", async (event) => {
  const slider = event.target.closest(".rating-slider");
  if (!slider) return;
  const panel = slider.closest(".rating-panel");
  if (!panel) return;
  const card = panel.closest(".film-card");
  setRatingError(panel, "");
  if (!supabaseClient) {
    setRatingError(panel, "Ratings are unavailable right now.");
    return;
  }
  const filmId = card?.dataset.filmId;
  const ratingValue = Number(slider.value);
  if (!ratingValue) return;
  if (!filmId || filmId.length < 8) {
    console.error("Invalid film_id for listener vote submission.", {
      filmId,
      ratingValue,
      panel,
      card
    });
    setRatingError(panel, "We couldnâ€™t verify this film rating right now.");
    return;
  }
  if (typeof getVisitorId !== "function") {
    setRatingError(panel, "We couldnâ€™t verify your session to save this rating.");
    return;
  }
  const visitorId = getVisitorId();

  let castVoteResponse;
  try {
    castVoteResponse = await fetch("https://johklrouorflqfmzpiaw.supabase.co/functions/v1/cast_vote", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        apikey: SUPABASE_ANON_KEY,
        Authorization: `Bearer ${SUPABASE_ANON_KEY}`
      },
      body: JSON.stringify({
        film_id: filmId,
        visitor_id: visitorId,
        rating: ratingValue
      })
    });
  } catch (error) {
    console.error("Rating update failed.", error);
    setRatingError(panel, "Rating failed. Try again.");
    return;
  }

  let castVotePayload = null;
  try {
    castVotePayload = await castVoteResponse.json();
  } catch (error) {
    console.error("Failed to parse cast_vote response.", error);
  }

  if (!castVoteResponse.ok || castVotePayload?.error) {
    const errorMessage = castVotePayload?.error || castVotePayload?.message;
    setRatingError(panel, errorMessage ? `Rating failed: ${errorMessage}` : "Rating failed. Try again.");
    return;
  }

  const listenerRating = listenerScores[filmId] ?? 0;
  const yourRating = ratingValue;

  localRatings[filmId] = yourRating;
  saveLocalRatings();
  updateRatingUI(filmId, listenerRating, yourRating);

  const weightedPercent = Number(castVotePayload?.weighted_percent);
  const listenerCount = Number(castVotePayload?.listener_count);

  audienceScores[filmId] = {
    weighted_percent: Number.isFinite(weightedPercent)
      ? weightedPercent
      : audienceScores[filmId]?.weighted_percent,
    listener_count: Number.isFinite(listenerCount)
      ? listenerCount
      : audienceScores[filmId]?.listener_count ?? 0
  };

  updateAudienceScoreUI(filmId, audienceScores[filmId], { highlight: true });
  await refreshListenerVotesForFilm(filmId);
  setAwardsLastUpdated(new Date());
  renderFilmAwards();

  if (isAudienceDrivenSort()) {
    const savedY = window.scrollY;
    await render({ skipScoreRefresh: true });
    window.scrollTo(0, savedY);
  }
});


container.addEventListener("click", (event) => {
  const trigger = event.target.closest(".transcript-link");
  if (!trigger) return;
  const txtUrl = trigger.dataset.transcriptTxt;
  if (!txtUrl) return;
  openTranscriptModal({
    title: trigger.dataset.transcriptTitle,
    txtUrl,
    trigger
  });
});

transcriptModal?.addEventListener("click", (event) => {
  if (event.target.closest("[data-transcript-close]")) {
    closeTranscriptModal();
  }
});

container.addEventListener("click", (event) => {
  const infoButton = event.target.closest(".listener-info");
  if (!infoButton) return;
  const wrapper = infoButton.closest(".listener-info-wrap");
  if (!wrapper) return;
  event.stopPropagation();
  if (openTooltip && openTooltip !== wrapper) {
    closeOpenTooltip();
  }
  const isOpen = wrapper.classList.toggle("open");
  infoButton.setAttribute("aria-expanded", String(isOpen));
  if (isOpen) {
    openTooltip = wrapper;
    requestAnimationFrame(() => setTooltipAlignment(wrapper));
  } else {
    openTooltip = null;
  }
});

document.addEventListener("click", (event) => {
  if (!openTooltip) return;
  if (event.target.closest(".listener-info-wrap")) return;
  closeOpenTooltip();
});

document.addEventListener("keydown", (event) => {
  if (event.key === "Escape") {
    closeOpenTooltip();
  }
});

document.addEventListener("keydown", handleTranscriptKeydown);

window.addEventListener("resize", () => {
  if (openTooltip) {
    setTooltipAlignment(openTooltip);
  }
});

  initInfiniteScroll();
  loadFilms();
});

function updateRatingUI(filmId, listenerRating, yourRating) {
  document.querySelectorAll(`.rating-panel[data-film-id="${filmId}"]`).forEach(panel => {
    const slider = panel.querySelector(".rating-slider");
    const hasRating = Number.isFinite(Number(yourRating)) && Number(yourRating) > 0;

    panel.classList.toggle("is-voted", hasRating);
    setRatingError(panel, "");

    if (slider) {
      slider.value = hasRating ? String(yourRating) : "5";
    }
    updateRatingOutput(panel, hasRating ? yourRating : null);

  });

  document.querySelectorAll(`[data-listener-score="${filmId}"] .listener-score-text`).forEach(el => {
    el.textContent = `Listeners Rating: ${formatListenerRating(listenerRating)}`;
  });
}

function updateRatingOutput(panel, value) {
  if (!panel) return;
  const output = panel.querySelector("[data-rating-output]");
  if (!output) return;
  output.textContent = value ? `${value}/10` : "Vote now";
}

function closeOpenTooltip() {
  if (!openTooltip) return;
  const button = openTooltip.querySelector(".listener-info");
  openTooltip.classList.remove("open");
  if (button) button.setAttribute("aria-expanded", "false");
  openTooltip = null;
}

function setTooltipAlignment(wrapper) {
  if (!wrapper) return;
  const tooltip = wrapper.querySelector(".listener-tooltip");
  if (!tooltip) return;
  tooltip.classList.remove("align-right");
  const rect = tooltip.getBoundingClientRect();
  if (rect.right > window.innerWidth - 8) {
    tooltip.classList.add("align-right");
  }
}

function loadMoreFilms() {
  if (loadingMore) return;
  if (visibleCount >= currentTotal) return;
  updateLoadingState(true);
  window.setTimeout(() => {
    visibleCount = Math.min(visibleCount + PAGE_SIZE, currentTotal);
    render({ skipScoreRefresh: true });
  }, 400);
}

function handleScrollFallback() {
  if (loadingMore) return;
  if (visibleCount >= currentTotal) return;
  const nearBottom = window.innerHeight + window.scrollY >= document.body.offsetHeight - 200;
  if (nearBottom) loadMoreFilms();
}

function initInfiniteScroll() {
  if (!sentinelEl) return;
  if ("IntersectionObserver" in window) {
    const observer = new IntersectionObserver(entries => {
      if (entries.some(entry => entry.isIntersecting)) {
        loadMoreFilms();
      }
    }, { rootMargin: "200px" });
    observer.observe(sentinelEl);
  } else {
    window.addEventListener("scroll", handleScrollFallback, { passive: true });
  }
}

</script>

</body>
</html>
